SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_blog_article
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_article`;
CREATE TABLE `t_blog_article`  (
  `ID` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `article_title` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `article_author` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '作者',
  `article_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文章内容',
  `article_tag_id` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标签(存放标签id)',
  `article_dec` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '简介',
  `article_classify_id` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '所属分类',
  `is_main` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否主页显示(1=是，0=否)',
  `is_own` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否原创(1=原创，0=转载)',
  `article_from` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '转载地址',
  `is_rec` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否推荐',
  `article_view` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览量',
  `article_comment` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论量',
  `article_creation_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '发表时间',
  `article_last_update_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '最后更新时间',
  `article_status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '状态(1=发表，0=草稿)',
  `article_content_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '内容类型(1=markdown，2=富文本)',
  `article_cover_img` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '封面地址',
  `is_delete` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '删除标志(1=删除，0=未删除)',
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_article
-- ----------------------------
INSERT INTO `t_blog_article` VALUES (1, 'SpringMVC的常用注解', 'OIA', '# SpringMVC的常用注解\n\n##  @Controller注解\n\n> @Controller用于标记一个类，使用它标记的类就是一个SpringMVC Controller对象，即一个控制器类	\n\n- 使用```<context:component-scan/>```元素，启动包扫描功能，注册带有@Contorller、@Service、@repository、@Component等注解的类成为Spring的Bean。\n\n配置文件如下：\n\n```xml\n<context:component-scan base-package=\"包的路径\"/>\n```\n\n## @RequestMapping注解\n\n### RequestMapping注解简介\n\n> @RequestMapping注解，指示了Spring用哪一个类或方法来处理请求动作，该注解可用于类或方法。\n> @RequestMapping注解可以用来注释一个控制器类，所有方法都将映射为相对于类级别的请求，表示该控制器处理的所有请求都被映射到value属性所指示的路径下。\n\n示例代码：\n\n```java\n@Controller\n@RequestMapping(value=\"/user\")\npublic class UserController {\n    @RequestMapping(value=\"/register\")\n    public String register() {\n        return \"register\";\n    }\n    @RequestMapping(value=\"/login\")\n    public String login() {\n        return \"login\";\n    }\n}\n```\n\n### RequestMapping注解支持的常用属性\n\n#### value属性\n\n> @RequestMapping 是一个用来处理请求地址映射的注解，可以注释一个类或方法。\n\n采用了@RequestMapping注释的方法将成为一个请求处理方法，例如：\n\n```java\n@RequestMapping(value=\"/hello\")\npublic ModelAndView hello() {\n    return ...;\n}\n```\n\n**如果只有唯一的属性时，则可以省略属性名，以下两个注解的含义相同。但如果有超过一个属性，就必须写上value属性名称。**\n\n```java\n@RequestMapping(value=\"/hello\")\n@RequestMapping(\"/hello\")\n```\n\nvalue属性的值可以是一个空字符串，此时该方法被映射到如下请求URL：```http://localhost:8080/context```\n\n\n\n#### method属性\n\n> 该属性用来指示该方法仅处理哪些HTTP请求方式。\n\n  ```@RequestMapping(value=\"/hello\", method=RequestMethod.POST)```，表示该方法只支持POST请求。\n\n  也可以同时支持多个HTTP请求方式\n\n  ```RequestMapping(value=\"/hello\", method={RequestMethod.POST,RequestMethod.GET})```\n\n  如果没有指定method属性值，则请求处理方法可以处理任意的HTTP请求方式。\n\n\n\n#### consumes属性\n\n> 该属性指定请求的提交内容类型（Content-Type）\n\n  ```@RequestMapping(value=\"/hello\", consumes=\"application/json\")```，表示方法仅处理request Content-Type为\"application/json\"类型的请求。\n\n\n\n#### produces属性\n\n> 该属性指定返回的内容类型，返回的内容类型必须是request请求头（Accept）中说包含的类型。\n\n  @RequestMapping(value=\"/hello\", produces=\"application/json\")，表示方法仅处理request请求中Accept头中包含了\"application/json\"的请求，同时指明了返回的内容类型为application/json。\n\n\n\n#### params属性\n\n> 该属性指定request中必须包含某些参数值时，才让该方法处理。\n\n  ```@RequestMapping(value=\"/hello\", params=\"myParam=myValue\")```，表示该方法仅处理其中名为\"myParam\"、值为\"myValue\"的请求。\n\n\n\n#### headers属性\n\n> 该属性指定request中必须包含某些特定的header值时，才能让该方法处理请求。\n\n  ```@RequestMapping(value=\"/hello\", headers=\"Referer=http://www.aaa.com/\")```，表示该方法仅处理header中包含了指定\"Referer\"请求头和对应值为\"http://www.aaa.com\"请求。\n\n\n\n### Model、ModelMap以及ModelAndView\n\n   &emsp;&emsp;SpringMVC在内部使用了一个org.springframework.ui.Model接口存储模型数据，它的功能类似java.util.Map接口，但是比Map易于使用。org.springframewok.ui.ModelMap接口实现了Map接口。\n    &emsp;&emsp;SpringMVC在调用处理方法之前会创建一个隐含的模型对象，作为模型数据的存储容器。\n    &emsp;&emsp;如果处理方法的参数为Model或ModelMap类型，则SpringMVC会见隐含模型的引用传递给这些参数，在处理方法内部，开发者可以通过这个参数对象访问模型中的所有数据，也可以向模型中添加新的数据，添加方法如下：\n      ```addAttribute(String attributeName, Object attributeValue)```\n&emsp;&emsp;控制器处理方法的返回值如果是ModelAndView，则其即包括模型数据信息，也包含视图信息，这样SpringMVC将使用包含的视图对模型数据进行渲染。可以简单的将模型数据看成一个Map<String, Object>对象。\n&emsp;&emsp;ModelAndView对象添加模型数据的方法如下。\n ```addObject(String attributeName, Object attributeValue)```\n&emsp;&emsp;可以通过如下方法设置视图\n ```setVIewName(String viewName)```\n\n\n### 页面转发\n\n> 在JSP中页面转发有两种情况：服务器内部跳转（forward）和客户端重定向（redirect）\n\n#### 转发到JSP页面\n\n**返回值是字符串：**\n\n默认使用服务器内部跳转（forward）。\n\n```return \"main\";```\n\n客户端重定向，在返回的字符串前加上\"redirect:/\"。\n\n```return \"redirect:/main.jsp\";```\n\n**使用ModelAndView：**\n\n默认使用服务器内部跳转（forward）。\n\n```\nmv.setViewName(\"main\");\n```\n希望重定向。\n\n\n```\nmv.setViewName(\"redirect:/main.jsp\");\n```\n\n\n由于客户端重定向（redirect）相当于在浏览器重新发送请求，所以不能访问WEB-INF下的资源文件，而且也必须写资源文件后缀名，即.jsp，因为此时springmvc-config.xml文件的视图解析器设置的前缀和后缀都将无效。\n\n\n#### 转发到控制器的请求处理方法\n\n**请求处理方法返回值是字符串：**\n\n```return \"forward:/main\";```\n\n```return \"redirect:/main\";```\n\n**返回值是ModelAndView：**\n\n```\nmv.setViewName(\"forward:/main\");\n```\n\n```\nmv.setViewName(\"redirect:/main\");\n```\n\n\n\n## @RequestParam注解\n\n> @RequestParam注解用于将指定的请求参数赋值给方法中的形参。\n\n请求处理方法参数的可选类型为Java基本数据类型和String。	\n\n```java\n@RequestMapping(value=\"/login\")\npublic ModelAndView login(@RequestParam(\"loginname\") String loginname,\n                         @RequestParam(\"password\") String password) {\n    return ...;\n}\n```\n\n需要注意的是，如果请求中不 包含\"loginname\"参数，则将会产生异常！因此，如果不能保证存在loginname参数，建议使用：\n\n```@RequestParam(value=\"loginname\", required=false)```\n\n## @PathVariable注解\n\n> @PathVariable注解可以非常方便地获得请求URL中的动态参数。\n>\n\n示例代码：\n\n```java\n@RequestMapping(value=\"/pathVariableTest/{userId}\")\npublic void pathVariableTest(@PathVariable Integer userId) {\n    ...\n}\n```\n\n假如请求的URL为```\"http://localhost:8080/VariableTest/pathVariableTest/1\"```,则自动将URL中模板变量{userId}绑定到通过@PathVariable注解的同名参数上，即userId变量将被赋值为1.\n\n## @MatrixVariable注解\n\n> @MatrixVariable注解拓展了URL请求地址的功能。使用@MatrixVariable注解时多个变量可以使用\";\"（分号）分隔，该注解允许开发者进行多条件组合查询。\n>\n\n示例代码\n\n```java\n@GetMapping(value=\"/matrixVariableTest/{userId}\")\npublic void matrixVariableTest(@PathVariable Integer userId,\n                              @MatrixVariable(value=\"name\", pathVar=\"userId\") String name,\n                              @MarixVariable(value=\"age\", pathVar=\"userId\") Integer age) {\n    ...\n}\n```\n\n假如请求的URL为```\"http://localhost:8080/VariableTest/matrixVariableTest/1;name=jack;age=23\"```，则自动将URL中模板变量{usrId}绑定到通过@PathVariable注解的同名参数上，即userId变量将被赋值为1；通过@MatrixVariable注解绑定name变量和age变量，即name变量将被赋值为jack，age变量将被赋值为23。\n\n需要注意的是，@MatrixVariable注解功能在SpringMVC中默认不启用的，启用它需要设置```enable-matrix-variables=\"true\"```。\n\n```<mvc:annotation-driven enable-matrix-variables=\"true\"/>```\n\n## @CrossOrigin 注解\n\n> @CrossOrigin注解用于在SpringMVC中处理跨域请求。\n\n| 属性             | 类型            | 是否必要 | 说明                                               |\n| ---------------- | --------------- | -------- | -------------------------------------------------- |\n| allowCredentials | String          | 否       | 包含与请求的域相关的Cookie，使用时必须指定具体的域 |\n| allowedeHeaders  | String[]        | 否       | 请求头中的请求列表                                 |\n| exposedHeaders   | String[]        | 否       | 客户端允许方法的响应头列表                         |\n| maxAge           | long            | 否       | 响应前的缓存最大有效时间，单位是秒                 |\n| methods          | RequestMethod[] | 否       | 请求支持的方法，默认支持RequestMapping中设置的方法 |\n| origins          | String[]        | 否       | 所有支持域的集合，如果没有定义，默认支持所有域     |\n| value            | String[]        | 否       | 同origins属性一样                                  |\n\n\n\n## @RequestHeader 注解\n\n> @RequestHeader注解用于将请求的头信息数据映射到功能处理方法的参数上。\n\n@RequestHeader注解示例代码\n\n```java\n@RequestMapping(value=\"/requestHeaderTest\")\npublic void requestHeaderTest(@RequestHeader(\"User-Agent\") String userAgent,\n                             @RequestHeadr(value=\"Accept\") String[] accepts)\n```\n\n以上配置将自动将请求头“User-Agent”的值赋到userAgent变量上，并将请求头“Accept”的值赋到accepts变量上。\n\n\n\n## @Cookie Value注解\n\n> @CookieValue注解用于将请求的Cookie数据映射到功能处理方法的参数上。\n\n@CookieValue注解示例代码\n\n```java\n@ReqeustMapping(vcalue=\"/cookieValueTest\")\npublic void cookieValueTest(\n    @CookieValue(value=\"JSESSIONID\", defaultValue=\"\")String sessionId)\n```\n\n​	以上配置会自动将Cookie中JSESSIONID的值设置到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。\n\n\n\n## @RequestAttribute注解\n\n> @RequestAttribbute注解用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于request作用域中的属性，将该属性转换到目标方法的参数。\n\n​	@RequestAttribute注解示例代码\n\n```java\n@RequestMapping(value=\"/attributeTest\")\npublic void attributeTest(\n	@RequestAttribute(value=\"username\") String username)\n```\n\n以上代码会指定将request作用域中名为username的属性的值设置到username参数上。\n\n\n\n## @SessionAttribute注解\n\n> @SessionAttribute注解用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于session作用域中的属性，将该属性转换到目标方法的参数。\n\n​	@SessionAttribute注解示例代码\n\n```java\n@RequestMapping(value=\"/attributeTest\")\npublic void attributeTest(\n		@SessionAttribute(value=\"username\") String username)\n```\n\n​	以上代码会自动将session作用域中名为username的属性的值设置到username参数上。\n\n\n\n## @SessionAttributes注解\n\n> @SessionAttributes注解允许我们有选择的指定Model中的哪些属性转存到HttpSession对象当中。\n\n@SessionAttributes注解只能声明在类上，而不能声明在方法上。\n\n\n\n## @ModelAttribute注解\n\n> @ModelAttribute注解用于将请求参数绑定到对象。@ModelAttribute注解只支持一个属性value，类型为String，表示绑定的属性名称。\n\n被@ModelAttribute注解的方法会在Controller每个方法执行前被执行，因此在一个Controller被映射到多个URL时，要谨慎使用。\n\n@ModelAttribute注解示例代码\n\n```java\n@Controller\npublic class ModelAttribute1Controller {\n        @ModelAttribute(\"loginname\")\n        public String userModel1(@RequestParam(\"loginname\") String loginname) {\n            return loginname;\n        }\n        @RequestMapping(value=\"/login1\")\n        public String login1() {\n            return \"result1\";\n        }\n}\n```\n\n​		在ModelAttribute1Controller类中除了@ReqesutMapping映射的login1方法之外，还提供了一个userModel1方法，该方法上有一个@ModelAttribute注解。此处@ModelAttribute注解默认的value值为“loginname”，用来指定model属性的名称，而model属性的值就是userModel1方法的返回值。被@ModelAttribute注解的userModel1方法会先于login1调用，它把请求参数loginname的值赋给loginname变量，并设置了一个属性loginname到Model中，而属性的值就时loginname变量的值。\n\n\n\n## @ReqeustBody注解\n\n> @RequestBody注解常用来处理Content-Type：不是application/x-www-form-urlencoded编码的内容，例如application/json、application/xml等。@RequestBody注解通过使用HandlerAdapter配置的HttpMessageConverters来解析JSON或XML数据，然后绑定到相应的Bean上。\n\n### HttpMessageConverter<T>接口\n\n> 	负责将请求信息转换为一个对象（类型为T），并将对象（类型为T）绑定到请求方法的参数上或输出为响应信息。DIspatcherServlet默认已经装配了RequestMappingHandlerAdapter作为HandlerAdapter组件的实现类，即HttpMessageConverter由RequestMappingHandlerAdapter使用，将请求信息转换为对象，或将对象转换为响应信息。\n\nHttpMessageConverter<T>接口中定义了以下几个方法：\n\n- boolean **canRead**(Class<?> clazz, MediaType mediaType)\n\n- boolean **canWrite**(Class<?> clazz, MediaType mediaType)\n\n- List<MediaType> **getSupportedMediaTypes**()\n\n- T **read**(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\n- void write(T t, MediaType contentType, HttpOutputMessage outputMessage)\n\n  String为HttpMessageConverter<T>提供了多个实现类，这些实现类组成了一个功能强大、用途广泛的信息转换家族。列举几个主要的：\n\n  - StringHttpMessageConverter。将请求信息转换为字符串。泛型T为String类型，可以读取所有媒体类(*/*)的请求信息，可通过设置supportMediaTypes属性指定媒体类型。响应信息的媒体类型为text/plain（即Content-Type的值）。 \n  - **MappingJackson2HttpMessageConverter。利用Jackson开源类包读写JSON数据。泛型T为Object类型，可以读取application/json类型的数据，响应信息的类型为application/json。**\n\n\n\n### 转换JSON数据\n\n> 	@RequestBody注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到Controller中方法的参数上。\n\n当前台页面使用GET或POST方式提交数据时，数据编码格式由请求头的ContentType指定。可以分为以下几种情况：\n\n- **application/x-www-form-urlencoded**。这种情况的数据@RequestParam、@ModelAttribute也可以处理，@RequestBody也可以处理。\n- **multipart/form-data**。@RequestBody不能处理这种格式的数据。\n- **application/json**、**application/xml**等格式的数据，必须使用@RequestBody来处理。\n\n\n\n### 自定义HttpMessageConverter接收JSON格式的数据\n\n配置文件：\n\n```xml\n<!-- 配置fastjson中实现HttpMessageConverter接口的转换器 -->\n<!-- FastJsonHttpMessageConverter是fastjson中实现HttpMessageConverter接口的类 -->\n<bean id=\"fastJsonHttpMessageConverter\" class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\">\n	<!-- 加入支持的媒体类型：返回contentType -->\n    <property name=\"supportedMediaTypes\">\n    	<list>\n        	<!-- 这里顺序不能反，一定先写text/html，不然IE下会出现下载提示 -->\n            <value>text/html;charset=UTF-8</value>\n            <value>application/json;charset=UTF-8</value>\n        </list>\n    </property>\n</bean>\n```\n\n```<mvc:message-converters register=default=\"false\">```设置不使用默认的消息转换器。\n\n\n\n## @ResponseBody注解\n\n> @ResponseBody注解用于将Controller的请求处理方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。当返回的数据不是HTML标签的页面时，而是其他某种格式的数据时（如JSON、XML等）使用它。\n\n不走视图解析器。\n\n\n\n## @RestController注解\n\n> @RestController注解本身使用@Controller和@ResponseBody注解。使用了 @RestController注解的类会被看作一个Controller，而该类中所有使用@RequestMapping注解的方法都默认使用了@ResponseBody注解。\n\n\n\n## SpringMVC的异常处理\n\n1. 使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver。\n2. 使用@ExceptionHandler注解实现局部异常处理或使用@ControllerAdvice注解实现统一异常处理\n\n### @ResponseStatus注解\n\n> @ResponseStatus注解，通常修饰的是一个异常类\n\n先声明一个自定义异常类，在自定义异常类上面加上@ResponseStatus注解，表示在系统运行时期，当抛出自定义异常的时候，使用@ResponseStatus注解中声明的value属性和reason属性将异常信息返回给客户端。\n\n示例代码\n\n```java\n@ResponseStatus(reason=\"查询数据失败\")\npublic class BookException extends RunTimeException{\n}\n\n@Controller\npublic class BookController{\n    \n    @GetMapping(\"/find\")\n	public String find() throws Exception{\n        try {\n            int i = 5/0;\n            return \"success\";\n        } catch(Exception e) {\n            throw new BookException();\n        }\n    }\n\n}\n```\n\n\n\n### @ExceptionHandler注解\n\n> @Exceptionhandler注解的作用对象为方法，并且运行时有效，value()可以指定异常类\n\n@ExceptionHandler注解的方法可以支持的参数除了HttpServletRequest、HttpServletRespnse等对象外，还支持一个异常参数，包括一般的异常或自定义异常。如果注解没有指定异常类，会默认进行映射。\n\n\n\n@ControllerAdvice注解\n\n> ControllerAdvice是一个控制器增强功能注解\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '1,4,8', 'SpringMVC相关的常用注解', '1', '1', '1', '', '1', '1', '0', '2019-08-01', '2019-08-04', '1', '1', 'http://lsblog.vip/coverImg/20190801154707.jpg', '0');
INSERT INTO `t_blog_article` VALUES (2, 'SpringMVC的文件上传下载和拦截器机制', 'OIA', '## 文件上传\n\n**必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这种情况下，浏览器才会把用户选择的文件二进制数据发送给服务器。**\n\n*一般使用Commons FileUpload组件*\n\n\n\nSpringMVC实现了一个MultipartResolver类：CommonsMultipartResolver，因此SpringMVC上传文件需要依赖Apache Commons FileUpload组件（commons-fileupload和commons-io）\n\n示例代码：\n\n前端：\n\n```html\n<form action=\"upload\" enctype=\"multipart/form-data\" method=\"post\">\n    <input type=\"file\" name=\"file\"/>\n</form>\n```\n\n后端：\n\n```java\n@Controller\npublic class FileUploadController{\n    //上传文件会自动绑定到MultipartFile\n    @PostMapping(\"/upload\")\n    public String upload(HttpServletRequest request, \n                        @RequestParam(\"file\") MultipartFile file) throw Exception {\n        \n        //如果文件不为空，写入上传路径\n        if(!file.isEmpty()) {\n            //上传路径\n            String path = request.getServletContext().getRealPath(\"/images\");\n        	//上传文件名\n            String filename = file.getOriginalFilename();\n            File filepath = new File(path, filename);\n        	//判断路径是否存在，不存在就创建一个\n            if(!filepath.getParentFile().exists()) {\n                filepath.getParentFile().mkdirs();\n            }\n            //将上传的文件保存到一个目标文件当中\n            file.transferTo(new File(path+File.separator+filename));\n        	System.out.println(\"上传文件的路径：\" + (path+File.separator+filename));\n            return \"success\";\n        } else {\n            return \"error\";\n        }\n    }\n}\n```\n\n\n\n### MultipartFile对象的常用方法\n\n- `byte[] getBytes()` ：获取文件数据\n- `String getContentType()`： 获取文件MIME类型，如image/jpeg等\n- `InputStream getInputStream()`： 获取文件流\n- `String getName()`：获取表单中文件组件的名称\n- `String getOriginalFilename()`： 获取上传文件的原名\n- `long getSize()`： 获取文件的字节大小，单位为byte\n- `boolean isEmpty()`： 是否有上传的文件\n- `void transferTo(FIle dest)`：将上传的文件保存到一个目标文件中\n\nSpringMVC中默认没有装配MultipartResolver，如果要使用SpringMVC的文件上传功能，需要在上下文中配置。\n\n```xml\n<!-- 文件上传配置 -->\n<bean id=\"multipartResolver\" class=\"org.springframeword.web.multipart.commons.CommonsMultipartResolver\">\n    <!-- 上传文件大小上限，单位是字节（10MB） -->\n	<property name=\"maxUploadSize\">\n        <value>10485760</value>\n    </property>\n    <!-- 请求的编码格式，必须和jsp的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\n	<property name=\"defaultEncoding\">\n    	<value>UTF-8</value>\n    </property>\n</bean>  \n```\n\n\n\n## 文件下载\n\nSpringMVC提供了一个ResponseEntity类型，可以定义返回的BodyBuilder、HttpHeaders和HJttpStatus\n\n示例代码：\n\n```java\n@GetMapping(\"/download\")\npublic ResponseEntity<byte[]> download(HttpServletRequest request,\n                                      @RequestParam(\"filename\") String filename,\n                                      @RequestHeader(\"User-Agent\") String userAgent)\nthrow Exception{\n    //下载路径\n    String path = request.getServletContext().getRealPath(\"/images\");\n    //构建file\n    File file = new File(path + File.separator + filename);\n    //ok=200状态码\n    BodyBuilder builder = ResponseEntity.ok();\n    //内容长度\n    builder.contentLength(file.length());\n    //applicaiton/octet-stream:二进制流数据\n    builder.contentType(MediaType.APPLICATION_OCTET_STREAM);\n    //使用URLDecoder.decode对文件名进行解码\n    filename = URLEncoder.encode(filename, \"UTF-8\");\n    //设置实际的响应文件名，告诉浏览器文件要以附件形式打开\n    //不同的浏览器，处理方式不同，要根据浏览器版本进行区别判断\n    if(userAgent.indexOf(\"MSIE\") > 0) {\n        //如果是IE，只需要用UTF-8字符集进行URL编码即可\n        builder.header(\"Content-Disposition\", \"attachment; filename=\"+filename);\n    } else {\n        //而Firefox、Chrome等浏览器，则需要说明编码的字符集\n        //注意filename后面有个*号，在UTF-8后面有两个单引号\n        builder.header(\"Content-Disposition\", \"attachment; filename*=UTF-8\'\'\"+filename);\n    }\n    return builer.body(FileUtils.readFileToByteArray(file));\n}\n```\n\ndownload处理方法接收到页面传递的文件名filename后，使用Apache Commons FileUpload组件的FileUtils读取项目的images文件夹下的该文件，并将其构建成ResponseEntity对象返回给客户端下载。\n\n\n\n## 拦截器\n\n> Interceptor拦截器，它的主要功能是拦截用户的请求并进行相应的处理。比如用户权限验证，判断用户是否已经登录等。\n\n### HandlerInterceptor接口\n\nSpringMVC中的Interceptor拦截器拦截请求是通过实现HandlerInterceptor接口来完成的，在SpringMVC中定义一个Interceptor拦截器，通常在要定义的Interceptor拦截器类中实现Spring的HandlerInteceptor接口，或者继承抽象类HandlerInterceptorAdapter。\n\nHandlerInterceptor接口中定义了三个方法：\n\n- **boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)**：在请求处理前调用，当返回的是false则请求结束，当返回的是true，继续执行。\n- **void postHandle(HttpServletReqeust request, HttpServletResponse response, Object handler, ModelAndView mv)**：当前请求被处理之后，也就是Controller方法被调用之后执行，但是会在DispatcherServlet进行视图返回渲染之前被调用，所以可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。\n- **void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object hadnler, Exception exception)**：将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图后执行。主要进行资源的清理。\n\n示例代码：\n\n设计一个拦截器验证用户是否登录，没有登录，不可以访问除登录外页面和登录请求外的Controller\n\n```java\n/**\n * 拦截器必须实现HandlerInterceptor接口\n */\npublic class AuthorizationInterceptor implements HandlerInterceptor {\n\n    //不拦截\"/loginForm\" 和\"/login\"请求\n    private static final String[] IGNORE_URI = {\"/loginForm\", \"/login\"};\n\n    /**\n     * preHandle方法是进行处理器拦截用的，该方法将在Controller处理之前调用\n     * 该方法的返回值为true时拦截器才会继续往下执行，该方法的返回值为false时，整个请求就结束了\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"AuthorizationInterceptor preHandle...\");\n        //flag判断用户是否登录\n        boolean flag  = false;\n        //获取请求路径\n        String servletPath = request.getServletPath();\n        //判断请求是否需要拦截\n        for (String s : IGNORE_URI) {\n            if (servletPath.contains(s)) {\n                flag = true;\n                break;\n            }\n        }\n        //拦截请求\n        if (!flag) {\n            //1、获取session中的用户\n            User user = request.getSession().getAttribute(\"user\");\n            //2、判断用户是否已经登录\n            if (user == null) {\n                System.out.println(\"用户没有登录\");\n                request.setAttribute(\"message\", \"请先登录\");\n                request.getRequestDispatcher(\"loginForm\").forward(request, response);\n            } else {\n                System.out.println(\"用户登录了，可以访问\");\n                flag = true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 该方法将在Controller的调用之后执行，方法中可以对ModelAndView进行操作\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        System.out.println(\"AuthorizationInterceptor postHandle...\");\n    }\n\n    /**\n     * 该方法将在整个请求完成之后执行，主要作用是清理资源\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println(\"AuthorizationInterceptor afterCompletion...\");\n    }\n}\n\n```\n\n在springmvc-config.xml文件中配置拦截器\n\n```xml\n<!-- spring mvc拦截器配置 -->\n<mvc:interceptors>\n	<mvc:interceptor>\n		<!-- 拦截所有请求 -->\n        <mvc:mapping path=\"/\"/>\n        <!-- 使用bean顶一个Interceptor -->\n        <bean class=\"org.fkit.interceptor.AuthorizationInterceptor\"/>\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\n\n\n\n\n\n\n\n\n', '1,8', 'springmvc中文件的长传和下载，以及springmvc中如何应用拦截器', '1', '1', '1', '', '1', '2', '1', '2019-08-01', '2019-08-04', '1', '1', 'http://lsblog.vip/coverImg/20190801160003.jpg', '0');
INSERT INTO `t_blog_article` VALUES (3, 'pageHelper插件', 'OIA', '# pageHelper插件的使用\n\n1. 导入pageHelper的jar包\n\n   ```xml\n   <dependency>\n         <groupId>com.github.pagehelper</groupId>\n         <artifactId>pagehelper</artifactId>\n         <version>4.1.4</version>\n   </dependency>\n   ```\n\n2. 在mybatis.xml文件中配置\n\n   ```xml\n   <plugins>\n         <plugin interceptor=\"com.github.pagehelper.PageHelper\">\n             <property name=\"dialect\" value=\"mysql\"/>\n         </plugin>\n   </plugins>\n   ```\n\n3. 写一个sql语句，返回的结果为list\n\n   ```sql\n   select * from worker order by wno\n   ```\n\n4. service层\n\n   ```java\n   public List<Worker> getAllWorkers() {\n         List<Worker> allWorkers = managerDao.getAllWorkers();\n         return allWorkers;\n   }\n   ```\n\n5. controller层\n\n   ```java\n   @RequestMapping(value = \"/manager\")\n       public ModelAndView manager(HttpServletRequest request,\n                                   @RequestParam(required = true, defaultValue = \"1\") Integer pageIndex) {\n            ModelAndView mav = new ModelAndView();\n           //获取第pageIndex页，每页10条数据\n           PageHelper.startPage(pageIndex, 10);\n         	//紧跟着第一个select方法会被分页，后面的不会被分页，除非再次调用PageHelper.startPage\n           List<Worker> allWorkers = managerService.getAllWorkers();\n           //用pageInfo对结果进行包装\n           PageInfo<Worker> pagehelper = new PageInfo<Worker>(allWorkers);\n           mav.addObject(\"page\", pagehelper);\n           mav.addObject(\"workers\", allWorkers);\n           mav.setViewName(\"manager\");\n           return mav;\n       }\n   ```\n\n6. pageInfo类，pegeInfo是插件里面的类，包含了非常全面的分页属性\n\n   在使用pageInfo这个类的时候，要将查询出来的list放到pageInfo中去\n\n   ```java\n   List<Worker> allWorkers = managerService.getAllWorkers();\n   PageInfo<Worker> pagehelper = new PageInfo<Worker>(allWorkers);\n   ```\n\n   ```java\n   //当前页\n   private int pageNum;\n   //每页的数量\n   private int pageSize;\n   //当前页的数量\n   private int size;\n   //排序\n   private String orderBy;\n   \n   //由于startRow和endRow不常用，这里说个具体的用法\n   //可以在页面中\"显示startRow到endRow 共size条数据\"\n   \n   //当前页面第一个元素在数据库中的行号\n   private int startRow;\n   //当前页面最后一个元素在数据库中的行号\n   private int endRow;\n   //总记录数\n   private long total;\n   //总页数\n   private int pages;\n   //结果集\n   private List<T> list;\n   \n   //第一页\n   private int firstPage;\n   //前一页\n   private int prePage;\n   //下一页\n   private int nextPage;\n   //最后一页\n   private int lastPage;\n   \n   //是否为第一页\n   private boolean isFirstPage = false;\n   //是否为最后一页\n   private boolean isLastPage = false;\n   //是否有前一页\n   private boolean hasPreviousPage = false;\n   //是否有下一页\n   private boolean hasNextPage = false;\n   //导航页码数\n   private int navigatePages;\n   //所有导航页号\n   private int[] navigatepageNums;\n   ```\n\n7. jsp页面\n\n   ```jsp\n   <c:if test=\"${!page.isIsFirstPage()}\">\n   	<li><a href=\"manager?pageIndex=1\">首页</a></li>\n   	<li><a href=\"manager?pageIndex=${page.prePage}\">上一页</a></li>\n   </c:if>\n   <c:forEach begin=\"1\" end=\"${page.pages}\" var=\"p\">\n   	<a href=\"manager?pageIndex=${p}\">${p}</a>\n   </c:forEach>\n   <c:if test=\"${!page.isIsLastPage()}\">\n   	<li><a href=\"manager?pageIndex=${page.nextPage}\">下一页</a></li>\n   	<li><a href=\"manager?pageIndex=${page.lastPage}\">尾页</a></li>\n   </c:if>\n   ```\n# 问题\n\n- 当进行多表查询时，pageTotal总条数被改成了pageSize\n\n\n\n# 原因\n\n### 网上查找的原因\n\n1. ```java\n   PageHelper.startPage(pageIndex, 10);\n   //查询语句\n   pageInfo...\n   ```\n\n   再startPage之后，只能进行一次查询的操作，如果sql里面进行了多次查询，就会导致pageInfo的Total是当前页的总条数。\n\n2. 我在service层中取出数据做了别的操作，导致在controller里面取出数据时就有问题了。\n\n\n\n# 解决\n\n1.  在网上看到的一种思路是通过手动赋值pageTotal\n\n   ```java\n   List<State> stateList1 = managerService.getState();//在分页之前先查询一次，这次查询结果的总条数没有问题\n   PageHelper.startPage(pageIndex, 10);\n   List<State> stateList = managerService.getState();\n   PageInfo<State> page = new PageInfo<>(stateList);\n   page.setTotal(stateList1.size());//给pageInfo设置Total\n   ```\n\n   但是这种方法不能解决我的问题\n\n\n\n\n\n### 我的原因\n\n我通过一个左连接的sql查出来的list，在service层对查出来的数据做了一些操作，返回的是另外一个list\n\nsql：\n\n```sql\nselect w.wno, w.wname, d.height, d.weight, d.heart, d.blood\n        from worker w LEFT JOIN data d\n        on w.wno=d.no\n        order by wno\n```\n\nservice：\n\n```java\npublic List<state>getState(){\n    List<state> stateList = new ArrayList<>();\n    List<state> resultS = managerDao.selectAll();\n    if () {\n        //判断操作\n        stateList.add(...);\n    }\n    return stateList;\n}\n```\n\ncontroller：\n\n```java\nPageHelper.startPage(pageIndex, 10);\nList<state> stateList = managerService.getState();\nPageInfo<state> page = new PageInfo<>(stateList);\n```\n\n最后的解决方法是在service层返回通过sql查出来的List，而不是我在service层new的List\n\npageInfo应该是对sql语句查出来的List进行分页操作，不能对我new出来的List进行分页操作', '6,7', '关于mybatis的pagehelper插件的使用，以及在使用中遇到的问题', '1', '1', '1', '', '1', '0', '0', '2019-08-01', '2019-08-01', '1', '1', 'http://lsblog.vip/coverImg/20190801160341.png', '0');
INSERT INTO `t_blog_article` VALUES (4, 'MyBatis框架简要介绍', 'OIA', '# MyBatis体系结构\n\n- ### SqlSessionFactory\n\n> 是单个数据库映射关系经过编译后的内存镜像\n\n1. 通过SqlSessionFactoryBuilder对象获取SqlSessionFactory对象的实例。\n2. SqlSessionFactoryBuilder对象通过配置文件或预先定制的Configuration的实例构建。\n3. 每个MyBatis应用程序都以一个SqlSessionFactory对象的实例为核心，其是线程安全的。\n4. SqlSessionFactory一旦被创建，在应用程序的执行期间都存在。所以不需要重复创建多次。\n5. SqlSessionFactory是创建SqlSession的工厂\n6. 常用方法：\n   - ```SqlSession openSession()```：创建SqlSession对象\n\n- ### SqlSession\n\n> 是执行持久化操作的对象，类似JDBC中的Connection\n\n1. 是应用程序和持久化存储层之间执行交互操作的一个单线程对象。\n2. SqlSession对象包含了以数据库为背景的所有执行SQL操作的方法，底层封装了JDBC连接，可以用SqlSession实例来直接执行已映射的SQL语句。\n3. 每个线程都有自己的SqlSession实例。\n4. SqlSession的实例不能被共享，也是线程不安全的。\n\n\n\n# MyBatis的配置文件\n\n**MyBatis的持久化操作离不开SqlSessionFactory对象，该对象的openSession()方法可以创建SqlSession对象**\n\nMyBatis初始化基本过程：\n\n```java\n//读取mybatis-config.xml文件\nInputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n//初始化MyBatis，创建SqlSessionFactory类的实例\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.build(inputStream);\n//创建Session实例\nSqlSession session = sqlSessionFactory.openSession();\n```\n\nMyBatis的初始化就发生在第二句话\n\n\n\n## MyBatis的配置文件结构\n\n- properties 属性\n\n  这些属性都可以通过外部配置动态替换\n\n- settings 设置\n\n  可以改变MyBatis的运行时行为\n\n- tyAliases 类型命名\n\n  是为Java类型设置一个短的名字，只和XML配置有关，仅为了减少类完全限定名的冗余\n\n  形式：\n\n  ```java\n  <typeAliases>\n  	<typeAlias alias=\"user\" type=\"com.demo.domain.User\"/>\n  </typeAliases>\n  ```\n\n  这样user可以用在任何使用com.demo.domain.User的地方\n\n  ```java\n  <typeAliases>\n  	<typeAlias name=\"com.demo.domain\"/>\n  </typeAliases>\n  ```\n\n  com.demo.domain包下的每一个JavaBean，没有注解的情况下，则使用Bean的首字母小写的非限定类名作为别名。com.demo.domain.User的别名为user。\n\n  如果有注解，则别名为注解的值\n\n  ```java\n  @Alias(\"user\")\n  public class User{\n      ...\n  }\n  ```\n\n- typeHandlers 类型处理器\n\n- objectFactory 对象工厂\n\n  Mybatis每次创建结果对象的新实例时，会使用一个对象工厂（objectFactory）实例来完成。默认的对象工厂是实例化目标类。\n\n- environments 环境配置\n\n  环境配置实际就是数据源的配置。可以配置多种环境，将sql映射到多种数据库。但要注意每个数据库对应一个SqlSessionFactory，需要连接几个数据库就要几个SqlSessionFactory实例。\n\n- mapper 映射器\n\n  写完sql语句，通过mapper映射器告诉mybatis去哪里找映射文件，进而找到sql语句\n\n\n\n# Mapper XML映射文件\n\n参数符号**#{XXX}**，创建一个预处理语句参数，在JDBC中由一个\"**?**\"来标识。\n\nSQL映射文件常用元素：\n\n- select：映射查询语句\n- insert：映射插入语句\n- update：映射更新语句\n- delete：映射删除语句\n- sql：可以被其他语句块引用的可重用语句块\n- cache：给命名空间的缓存配置\n- cache-ref：其他命名空间缓存配置的引用\n- resultMap：描述如何从数据库结果集中加载对象\n\n关联查询：\n\n```xml\n<!--映射学生对象-->\n<resultMap id=\"student\" type=\"com.demo.domain.Student\">\n    <id property=\"id\" column=\"id\"/>\n    <result property=\"name\" column=\"name\"/>\n    <result property=\"sex\" column=\"sex\"/>\n    <result property=\"age\" column=\"age\"/>\n    <!--关系映射-->\n    <association property=\"clazz\" column=\"clazz_id\" javaType=\"com.demo.domain.Clazz\" select=\"selectClazzById\"/>\n</resultMap>\n<select id=\"selectStudent\" resultType=\"com.demo.domain.Student\">\n    select * from t_student;\n</select>\n<select id=\"selectClazzById\" resultMap=\"student\">\n    select * from t_clazz;\n</select>\n```\n\n如要返回一个list\n\n```xml\n<collection property=\"students\" javaType=\"ArrayList\" column=\"id\" ofType=\"com.demo.domain.Student\" select=\"selectClazzById\"/>\n```\n\nofType：表示集合当中的类型\n\n\n\n# 动态SQL\n\n常用动态SQL元素：\n\n1. if\n2. choose(when、otherwise)\n3. where\n4. set\n5. foreach\n6. bind\n\n### if\n\n> 有条件的包含where子句的一部分\n\n```xml\n<mapper namespace=\"com.demo.domain.UserDao\">\n	<select id=\"selectUserByIdLike\" resultType=\"com.demo.domain.User\">\n        select * from t_user where clazz = \'1\'\n        <!--可选条件，如果传进来的参数有id，则加上id查询条件-->\n        <if test=\"id != null\">\n            and id = #{id}\n        </if>\n    </select>\n</mapper>\n```\n\n### choose(when、otherwise)\n\n> 当不想用所有的条件语句，只取其中一二的情况，类似Java中的switch语句\n\n```xml\n <select id=\"selectUser\" resultType=\"com.demo.domain.User\">\n        <!--\n			如果传入了id就按id查，没有传入id就按loginname和password查，否则查询性别是男的数据\n			如果即传入了id又传入了loginname和password，则按id查，因为使用了choose，按照sql中的顺序\n		-->\n        select * from t_user where clazz = \'1\'\n        <choose>\n            <when test=\"id != null\">\n                and id = #{id}\n            </when>\n            <when test=\"loginname != null and password != null\">\n                and loginname = #{loginname} and password = #{password}\n            </when>\n            <otherwise>\n                and sex = \'男\'\n            </otherwise>\n        </choose>\n    </select>\n```\n\n### where\n\n把刚刚的if实例改成如下所示：\n\n```xml\n<mapper namespace=\"com.demo.domain.UserDao\">\n	<select id=\"selectUserByIdLike\" resultType=\"com.demo.domain.User\">\n        select * from t_user where \n        <if test=\"clazz != null\">\n            clazz = #{clazz}\n        </if>\n        <if test=\"id != null\">\n            and id = #{id}\n        </if>\n    </select>\n</mapper>\n```\n\n如果不传参数：```select * from t_user where```\n\n如果传入id：```select * from t_user where and id = ?```\n\n也就是说不传入clazz参数，sql就会执行失败。\n\n修改如下：\n\n```xml\n<mapper namespace=\"com.demo.domain.UserDao\">\n	<select id=\"selectUserByIdLike\" resultType=\"com.demo.domain.User\">\n        select * from t_user \n        <where>\n        	<if test=\"clazz != null\">\n            	clazz = #{clazz}\n        	</if>\n        	<if test=\"id != null\">\n            	and id = #{id}\n        	</if>\n        </where>\n    </select>\n</mapper>\n```\n\n这样只有在一个以上的if条件有值得情况下才会插入where子句\n\n### set\n\n> set元素可以用于动态包含需要更新的列，舍去其他的列\n\n```xml\n<update id=\"updateUser\" parameterType=\"com.demo.domain.User\">\n       update t_user\n       <set>\n           <if test=\"name != null\">name=#{name}</if>\n           <if test=\"sex != null\">name=#{sex}</if>\n           <if test=\"age != null\">name=#{age}</if>\n           <if test=\"clazz != null\">name=#{clazz}</if>\n           <if test=\"loginname != null\">name=#{loginname}</if>\n           <if test=\"password != null\">name=#{password}</if>\n       </set>\n       where id = #{id}\n   </update>\n```\n\nset元素会动态前置SET关键字，也会消除无关的逗号\n\n### foreach\n\n> 用于集合的遍历，一般用于构建IN条件语句\n\n```xml\n<select id=\"selectUser\" resultType=\"com.demo.domain.User\">\n       select * from t_user where id in\n       <foreach collection=\"list\" item=\"item\" index=\"index\" open=\"(\" separator=\",\" close=\")\">\n           #{item}\n       </foreach>\n</select>\n```\n\n### bind\n\n> bind元素可以从OGNL表达式构建一个变量并将其绑定到上下文\n\n```xml\n<select id=\"selectUser\" resultType=\"com.demo.domain.User\">\n        <bind name=\"pattern\" value=\"\'%\' + _parameter.getName + \'%\'\"/>\n       select * from t_user\n       where loginname like #{pattern}\n   </select>\n```\n\n对loginname的模糊查询\n\n\n\n# MyBatis事务管理\n\n事务的特性（ACID）\n\n- **原子性**（Atomicity）：\n  - 事务是应用中最小的执行单位，如原子是自然界的最小颗粒，不可再分。事务是应用中不可再分的最小逻辑单元。\n- **一致性**（Consistency）：\n  - 事务执行的结果，必须使数据库从一种一致性状态变到另一种一致性状态，*一致状态*的含义是数据库中的数据应满足完整性约束。\n  - 当数据库只包含事务成功提交的结果时，数据库处于一致性状态。如果系统运行发生中断，某个事务没有完成而被迫中断，而该没有完成的事务对数据库所做的修改已经被写入数据库，此时，数据库就处于一种不正确的状态\n- **隔离性**（Isolation）：\n  - 各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的，即并发执行的事务之间不能互相影响\n- **持续性**（Durability）：\n  - 持续性也被称为持久性（Persistence），指事务一旦提交，对数据库中的数据的改变就是永久性的，即使是数据库系统遇到故障也不会丢失提交事务的操作。即对数据库所做的任何改变都要记录到永久存储器中，通常就是保存到物理数据库。\n\n\n\n## Trasaction接口\n\n- Trasaction接口\n\n  - JdbcTrasaction实现类\n  - ManagedTrasaction实现类\n\n- TrasactionFactory接口\n\n  - JdbcTrasactionFactory实现类\n\n  - ManagedTrasactionFactory实现类\n\n    用来获取事务的实例对象\n\nMyBatis事务管理分为两种形式：\n\n- 使用JDBC的事务管理机制\n- 使用managed的事务管理机制\n\n\n\n## 事务的配置\n\n事务的配置\n\n```xml\n<environment id=\"mysql\">\n            <!--\n            指定事务管理类型\n            type=\"JDBC\"使用JDBC的提交和回滚设置\n            type=\"MANAGED\"指让容器实现对事务的管理\n            -->\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${driver}\"/>\n                <property name=\"url\" value=\"${url}\"/>\n                <property name=\"username\" value=\"${username}\"/>\n                <property name=\"password\" value=\"${password}\"/>\n            </dataSource>\n        </environment>\n```\n\n在SSM中使用事务\n\n```xml\n<!-- 配置事务管理器 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">  \n        <property name=\"dataSource\" ref=\"dataSource\" />  \n    </bean> \n    <!-- 配置基于注解的声明式事务 @Transactional-->\n    <tx:annotation-driven transaction-manager=\"transactionManager\" />\n```\n\n在需要使用事务的方法上加上@Transactional注解\n\n\n\n# MyBatis缓存机制\n\nMyBatis的查询缓存分类：\n\n- 一级缓存：SqlSession级别的缓存\n- 二级缓存：mapper级别的缓存，多个SqlSession共享的\n\n### 一级缓存\n\n操作数据库时需要构造SqlSession对象，其中有一个HashMap用于存储缓存数据，不同的SqlSession之间的缓存数据区域（HashMap）是互不影响的。\n\n一级缓存的作用域是SqlSession范围，当在同一SqlSession中执行两次，那么第一次执行完会将数据写到缓存（内存），第二次查询时就直接去缓存中取数据，不再走底层数据库查询。如果数据库执行了DML（insert、update和delete），并提交到数据库，Mybatis会清空SqlSession中一级缓存，保证了缓存中存储的数据是最新的信息，避免出现脏读。\n\nMyBatis默认开启一级缓存，不需要配置。\n\n### 二级缓存\n\n使用二级缓存时，多个SqlSession使用同一个mapper的SQL语句去操作数据库，得到的数据会存在二级缓存区域，它是使用HashMap进行数据存储的，相较于一级缓存，二级缓存的范围更大，多个SqlSession可以共享二级缓存中的数据，二级缓存时夸SqlSession的。\n\n其作用域是mapper的同一个namespace。不同的SqlSession两次执行相同的namespace下的SQL语句，并且向SQL中传递的参数也相同，即最终执行相同的SQL语句，当第一个SqlSession调用close()关闭一级缓存时，第一次从数据库中查询的数据会被保存到二级缓存，第二次查询时会从二级缓存中获取数据，不走底层数据库查询。\n\n二级缓存需要配置\n\n```xml\n在mybatis-config.xml文件中\n<settings>\n	<!--开启二级缓存-->\n    <setting name=\"cacheEnabled\" value=\"true\"/>\n</settings>\n```\n\n```xml\n<!--开启当前mapper的namespace下的二级缓存-->\n<cache eviction=\"LRU\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/>\n```\n\n创建了一个LRU缓存，并每隔60s刷新，最大存储512个对象，返回的对象是只读的。\n\n使用二级缓存时，与查询结果映射的Java对象必须实现Serializable接口\n\n\n\n# MyBatis注解配置\n\n常用注解：\n\n- Select\n\n  ```java\n  @Select(\"SELECT * FROM T_USER WHERE id = #{id}\")\n  @Results({\n      @Result(id=true,column=\"id\",property=\"id\"),\n      @Result(column=\"name\",property=\"name\"),\n      @Result(column=\"age\",property=\"age\"),\n      @Result(column=\"sex\",property=\"sex\")\n  })\n  User selectUserById(int id);\n  \n  @Select(\"SELECT * FROM T_USER\")\n  List<User> selectAllUser();\n  ```\n\n- SelectProvider\n\n- Insert\n\n  ```java\n  @Insert(\"INSERT INTO T_USER(name,age,sex) VALUES(#{name},#{age},#{sex})\")\n  //使用数据库自增主键，keyProperty=\"id\"表示将插入数据生成的主键设置到user对象的id当中\n  @Options(useGeneratedKeys=true,keyProperty=\"id\")\n  int saveUser(User user);\n  ```\n\n- InsertProvider\n\n- Update\n\n  ```java\n  @Update(\"UPDATE T_USER SET name = #{name}, age = #{age}, sex = #{sex} where id = #{id}\")\n  void modifyUser(User user);\n  ```\n\n- UpdateProperty\n\n- Delete\n\n  ```java\n  @Delete(\"DELETE FROM T_USER WHERE id = #{id}\")\n  int deleteUserById(@Param(\"id\")int id);\n  ```\n\n- DeleteProperty\n\n- Result：在列和属性之间的单独结果映射\n\n- Results：多个结果映射列表\n\n- Options：提供配置选项的附加值，通常作为附加功能配置\n\n- One：复杂类型的单独属性值映射\n\n- Many：复杂类型的集合属性映射\n\n- Param：当映射器方法需要多个参数时，该注解可以给每个参数取一个名字，否则会以它们的顺序位置和SQL语句中的表达式进行映射。\n\n', '6,8', 'MyBatis框架的简要介绍，包括Mybatis的整体结构、配置文件、xml映射文件、动态sql、事务、缓存以及注解配置', '1', '1', '1', '', '1', '0', '0', '2019-08-04', '2019-08-04', '1', '1', 'http://lsblog.vip/coverImg/20190804030305.jpg', '0');
INSERT INTO `t_blog_article` VALUES (5, '本博客的楼中楼评论设计', 'OIA', '### 效果图\n\n![](http://lsblog.vip/articleImg/20190804202728.jpg)\n\n### 数据库设计\n\n在此只给出关键字段\n\n| 字段    | 注释           |\n| ------- | -------------- |\n| id      | 评论id         |\n| content | 评论内容       |\n| time    | 时间           |\n| pid     | 此评论的父级id |\n\n\n\n### 评论DTO\n\n```java\npublic class CommentDTO {\n\n    private Comment comment;\n\n    private List<CommentDTO> nodes;\n	\n    //getter/setter省略\n}\n```\n\n\n\n生成的数据格式应该如下：\n\n```json\n{\n    \"data\": [\n        {\n            \"comment\": {\n                \"commentContent\": \"7\",\n                \"commentPid\": \"\",\n                \"commentTime\": \"2019-08-04 16:23:40\",\n                \"id\": \"7\"\n            },\n            \"nodes\": []\n        },\n        {\n            \"comment\": {\n                \"commentContent\": \"3\",\n                \"commentPid\": \"\",\n                \"commentTime\": \"2019-08-04 16:11:16\",\n                \"id\": \"3\"\n            },\n            \"nodes\": [\n                {\n                    \"comment\": {\n                        \"commentContent\": \"5\",\n                        \"commentPid\": \"3\",\n                        \"commentTime\": \"2019-08-04 16:21:49\",\n                        \"id\": \"5\"\n                    },\n                    \"nodes\": []\n                }\n            ]\n        },\n        {\n            \"comment\": {\n                \"commentContent\": \"1\",\n                \"commentPid\": \"\",\n                \"commentTime\": \"2019-08-01 14:54:46\",\n                \"id\": \"1\"\n            },\n            \"nodes\": [\n                {\n                    \"comment\": {\n                        \"commentContent\": \"6\",\n                        \"commentPid\": \"1\",\n                        \"commentTime\": \"2019-08-04 16:23:28\",\n                        \"id\": \"6\"\n                    },\n                    \"nodes\": []\n                },\n                {\n                    \"comment\": {\n                        \"commentContent\": \"2\",\n                        \"commentPid\": \"1\",\n                        \"commentTime\": \"2019-08-01 14:56:14\",\n                        \"id\": \"2\"\n                    },\n                    \"nodes\": [\n                        {\n                            \"comment\": {\n                                \"commentContent\": \"4\",\n                                \"commentPid\": \"2\",\n                                \"commentTime\": \"2019-08-04 16:21:31\",\n                                \"id\": \"4\"\n                            },\n                            \"nodes\": []\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n```\n\n### 后端代码\n\n通过递归构建以上的json格式\n\n```java\n@Override\n    public List<CommentDTO> getMsgboardComment() {\n        List<Comment> rs = commentDao.selectList(query);\n        return buildComment(rs);\n    }\n\n\n    /**\n     * 构建评论列表\n     * @param list\n     * @return\n     */\n    private List<CommentDTO> buildComment(List<Comment> list) {\n        //将结果集转换成CommentDTO类型\n        List<CommentDTO> rsDto = new ArrayList<>();\n        for (Comment r : list) {\n            CommentDTO commentDTO = new CommentDTO();\n            commentDTO.setComment(r);\n            rsDto.add(commentDTO);\n        }\n\n        //获取所有根节点\n        List<CommentDTO> rootNodes = new ArrayList<>();\n        for (CommentDTO commentDTO : rsDto) {\n            if (commentDTO.getComment().getCommentPid() == null || \"\".equals(commentDTO.getComment().getCommentPid())) {\n                rootNodes.add(commentDTO);\n            }\n        }\n\n        //获取根节点下的子节点\n        List<CommentDTO> res = new ArrayList<>();\n        for (CommentDTO commentDTO : rootNodes) {\n            CommentDTO commentDTO1 = buildTree(commentDTO.getComment(), rsDto);\n            res.add(commentDTO1);\n        }\n        return res;\n    }\n\n    /**\n     * 递归构建评论列表\n     *\n     * @param list\n     * @return\n     */\n    private CommentDTO buildTree(Comment comment, List<CommentDTO> list) {\n        //获取当前节点对象\n        CommentDTO node = new CommentDTO();\n        for (CommentDTO commentDTO : list) {\n            if (commentDTO.getComment().getId().equals(comment.getId())) {\n                node = commentDTO;\n            }\n        }\n        //查询当前节点下的所有子节点\n        List<CommentDTO> childNodes = new ArrayList<>();//所有子节点\n        for (CommentDTO commentDTO : list) {\n            if (commentDTO.getComment().getCommentPid().equals(comment.getId())) {\n                childNodes.add(commentDTO);\n            }\n        }\n\n        for (CommentDTO child : childNodes) {\n            CommentDTO commentDTO = buildTree(child.getComment(), list);//递归\n            node.getNodes().add(commentDTO);//存入当前节点的子节点中\n        }\n\n        return node;\n    }\n```\n\n至此后端构建数据完成，现在要到前端去解析这些数据并渲染出来。\n\n### 前端代码\n\n```javascript\n//根节点\nvar rootNode;\n//子节点\nvar childNodes = [];\n//所有评论\nvar comments = [];\n\nfunction initComments() {\n    getAJax(site.msgboard, function (res) {\n        //处理评论信息\n        for (let i = 0; i < res.data.length; i++) {\n            rootNode = res.data[i].comment;\n            if (res.data[i].nodes.length > 0) {//说明有子节点\n                tree(res.data[i]);\n            }\n            let comment = {\n                node: rootNode,\n                childNodes: childNodes\n            };\n            comments.push(comment);\n            //初始化，构建下一条评论\n            rootNode = 0;\n            childNodes = [];\n        }\n    });\n}\n\nfunction tree(data) {\n    if (data.nodes.length > 0) {//有子节点\n        for (let i = 0; i < data.nodes.length; i++) {\n            childNodes.push(data.nodes[i].comment);\n            tree(data.nodes[i]);//递归，直到没有子节点\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n', '9', '楼中楼评论系统的设计与实现', '1', '1', '1', '', '1', '1', '0', '2019-08-04', '2019-08-04', '1', '1', 'http://lsblog.vip/coverImg/20190804203710.jpg', '0');

-- ----------------------------
-- Table structure for t_blog_classify
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_classify`;
CREATE TABLE `t_blog_classify`  (
  `ID` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `classify_name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `classify_dec` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `classify_creation_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `classify_last_update_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `is_delete` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_classify
-- ----------------------------
INSERT INTO `t_blog_classify` VALUES (1, '后端技术', '关于后端的各种技术，例如：Java编程语言、各种框架等。', '2019-08-01 15:29:31', '2019-08-01 15:29:31', '0');
INSERT INTO `t_blog_classify` VALUES (2, '前端技术', '关于HTML\\CSS\\JS等基础技术、Vue等前端框架和一些前端用到的插件。', '2019-08-01 15:31:33', '2019-08-01 15:31:33', '0');
INSERT INTO `t_blog_classify` VALUES (3, '数据结构和算法', '数据结构和算法，一般采用Java语言描述。', '2019-08-01 15:32:22', '2019-08-01 15:32:22', '0');
INSERT INTO `t_blog_classify` VALUES (4, '数据库', '关于数据库相关的知识，包括但不限于MySQL、Oracle等。', '2019-08-01 15:33:30', '2019-08-01 15:33:30', '0');
INSERT INTO `t_blog_classify` VALUES (5, '计算机', '计算机相关的知识，例如：操作系统、网络等。', '2019-08-01 15:34:22', '2019-08-01 15:34:22', '0');
INSERT INTO `t_blog_classify` VALUES (6, '其他', '个人兴趣相关', '2019-08-01 15:34:36', '2019-08-01 15:34:36', '0');

-- ----------------------------
-- Table structure for t_blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_comment`;
CREATE TABLE `t_blog_comment`  (
  `ID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `comment_nickname` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `comment_ip` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `comment_address` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `comment_email` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `comment_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `comment_from` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论来源(1=留言板，2=文章)',
  `comment_for` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '留言板/文章id',
  `comment_father` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '父级评论id',
  `comment_status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '审核状态(0=审核没通过，1=通过，2=待审核)',
  `comment_remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `is_delete` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_comment
-- ----------------------------
INSERT INTO `t_blog_comment` VALUES ('efc62bba2c1d40eb829c17d32c863878', '测试', '测试', '111.60.63.20', 'CHINA', '18772821935@163.com', '2019-10-01 16:45:07', '2', '2', '', '1', '', '0');

-- ----------------------------
-- Table structure for t_blog_link
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_link`;
CREATE TABLE `t_blog_link`  (
  `ID` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `link_url` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `link_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `link_dec` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `link_creation_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `is_delete` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for t_blog_log
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_log`;
CREATE TABLE `t_blog_log`  (
  `ID` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `log_user` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `log_dec` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `log_require_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `log_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `log_param` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `log_ip` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `log_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_log
-- ----------------------------
INSERT INTO `t_blog_log` VALUES (7, 'admin', '添加标签', '51', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"SpringMVC\\\"}\"}', '127.0.0.1', '2019-08-01 15:35:50');
INSERT INTO `t_blog_log` VALUES (8, 'admin', '添加标签', '122', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"JavaSE\\\"}\"}', '127.0.0.1', '2019-08-01 15:42:06');
INSERT INTO `t_blog_log` VALUES (9, 'admin', '添加标签', '51', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"JavaEE\\\"}\"}', '127.0.0.1', '2019-08-01 15:42:13');
INSERT INTO `t_blog_log` VALUES (10, 'admin', '添加标签', '55', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"基础\\\"}\"}', '127.0.0.1', '2019-08-01 15:44:53');
INSERT INTO `t_blog_log` VALUES (11, 'admin', '发表文章', '238', 'com.blog.admin.controller.ArticleController.addArticle()', '  data: {\"data\":\"{\\\"articleCoverImg\\\":[{\\\"name\\\":\\\"20190801154707.jpg\\\",\\\"url\\\":\\\"http://lsblog.vip/coverImg/20190801154707.jpg\\\",\\\"uid\\\":1564645628383,\\\"status\\\":\\\"success\\\"}],\\\"articleTitle\\\":\\\"SpringMVC的常用注解\\\",\\\"articleAuthor\\\":\\\"OIA\\\",\\\"isOwn\\\":true,\\\"articleFrom\\\":\\\"\\\",\\\"articleTag\\\":\\\"1,4\\\",\\\"articleClassify\\\":1,\\\"articleDec\\\":\\\"SpringMVC相关的常用注解\\\",\\\"articleContent\\\":\\\"# SpringMVC的常用注解\\\\n\\\\n##  @Controller注解\\\\n\\\\n> @Controller用于标记一个类，使用它标记的类就是一个SpringMVC Controller对象，即一个控制器类\\\\t\\\\n\\\\n- 使用```<context:component-scan/>```元素，启动包扫描功能，注册带有@Contorller、@Service、@repository、@Component等注解的类成为Spring的Bean。\\\\n\\\\n配置文件如下：\\\\n\\\\n```xml\\\\n<context:component-scan base-package=\\\\\\\"包的路径\\\\\\\"/>\\\\n```\\\\n\\\\n## @RequestMapping注解\\\\n\\\\n### RequestMapping注解简介\\\\n\\\\n> @RequestMapping注解，指示了Spring用哪一个类或方法来处理请求动作，该注解可用于类或方法。\\\\n> @RequestMapping注解可以用来注释一个控制器类，所有方法都将映射为相对于类级别的请求，表示该控制器处理的所有请求都被映射到value属性所指示的路径下。\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@Controller\\\\n@RequestMapping(value=\\\\\\\"/user\\\\\\\")\\\\npublic class UserController {\\\\n    @RequestMapping(value=\\\\\\\"/register\\\\\\\")\\\\n    public String register() {\\\\n        return \\\\\\\"register\\\\\\\";\\\\n    }\\\\n    @RequestMapping(value=\\\\\\\"/login\\\\\\\")\\\\n    public String login() {\\\\n        return \\\\\\\"login\\\\\\\";\\\\n    }\\\\n}\\\\n```\\\\n\\\\n### RequestMapping注解支持的常用属性\\\\n\\\\n#### value属性\\\\n\\\\n> @RequestMapping 是一个用来处理请求地址映射的注解，可以注释一个类或方法。\\\\n\\\\n采用了@RequestMapping注释的方法将成为一个请求处理方法，例如：\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/hello\\\\\\\")\\\\npublic ModelAndView hello() {\\\\n    return ...;\\\\n}\\\\n```\\\\n\\\\n**如果只有唯一的属性时，则可以省略属性名，以下两个注解的含义相同。但如果有超过一个属性，就必须写上value属性名称。**\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/hello\\\\\\\")\\\\n@RequestMapping(\\\\\\\"/hello\\\\\\\")\\\\n```\\\\n\\\\nvalue属性的值可以是一个空字符串，此时该方法被映射到如下请求URL：```http://localhost:8080/context```\\\\n\\\\n\\\\n\\\\n#### method属性\\\\n\\\\n> 该属性用来指示该方法仅处理哪些HTTP请求方式。\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", method=RequestMethod.POST)```，表示该方法只支持POST请求。\\\\n\\\\n  也可以同时支持多个HTTP请求方式\\\\n\\\\n  ```RequestMapping(value=\\\\\\\"/hello\\\\\\\", method={RequestMethod.POST,RequestMethod.GET})```\\\\n\\\\n  如果没有指定method属性值，则请求处理方法可以处理任意的HTTP请求方式。\\\\n\\\\n\\\\n\\\\n#### consumes属性\\\\n\\\\n> 该属性指定请求的提交内容类型（Content-Type）\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", consumes=\\\\\\\"application/json\\\\\\\")```，表示方法仅处理request Content-Type为\\\\\\\"application/json\\\\\\\"类型的请求。\\\\n\\\\n\\\\n\\\\n#### produces属性\\\\n\\\\n> 该属性指定返回的内容类型，返回的内容类型必须是request请求头（Accept）中说包含的类型。\\\\n\\\\n  @RequestMapping(value=\\\\\\\"/hello\\\\\\\", produces=\\\\\\\"application/json\\\\\\\")，表示方法仅处理request请求中Accept头中包含了\\\\\\\"application/json\\\\\\\"的请求，同时指明了返回的内容类型为application/json。\\\\n\\\\n\\\\n\\\\n#### params属性\\\\n\\\\n> 该属性指定request中必须包含某些参数值时，才让该方法处理。\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", params=\\\\\\\"myParam=myValue\\\\\\\")```，表示该方法仅处理其中名为\\\\\\\"myParam\\\\\\\"、值为\\\\\\\"myValue\\\\\\\"的请求。\\\\n\\\\n\\\\n\\\\n#### headers属性\\\\n\\\\n> 该属性指定request中必须包含某些特定的header值时，才能让该方法处理请求。\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", headers=\\\\\\\"Referer=http://www.aaa.com/\\\\\\\")```，表示该方法仅处理header中包含了指定\\\\\\\"Referer\\\\\\\"请求头和对应值为\\\\\\\"http://www.aaa.com\\\\\\\"请求。\\\\n\\\\n\\\\n\\\\n### Model、ModelMap以及ModelAndView\\\\n\\\\n   &emsp;&emsp;SpringMVC在内部使用了一个org.springframework.ui.Model接口存储模型数据，它的功能类似java.util.Map接口，但是比Map易于使用。org.springframewok.ui.ModelMap接口实现了Map接口。\\\\n    &emsp;&emsp;SpringMVC在调用处理方法之前会创建一个隐含的模型对象，作为模型数据的存储容器。\\\\n    &emsp;&emsp;如果处理方法的参数为Model或ModelMap类型，则SpringMVC会见隐含模型的引用传递给这些参数，在处理方法内部，开发者可以通过这个参数对象访问模型中的所有数据，也可以向模型中添加新的数据，添加方法如下：\\\\n      ```addAttribute(String attributeName, Object attributeValue)```\\\\n&emsp;&emsp;控制器处理方法的返回值如果是ModelAndView，则其即包括模型数据信息，也包含视图信息，这样SpringMVC将使用包含的视图对模型数据进行渲染。可以简单的将模型数据看成一个Map<String, Object>对象。\\\\n&emsp;&emsp;ModelAndView对象添加模型数据的方法如下。\\\\n ```addObject(String attributeName, Object attributeValue)```\\\\n&emsp;&emsp;可以通过如下方法设置视图\\\\n ```setVIewName(String viewName)```\\\\n\\\\n\\\\n### 页面转发\\\\n\\\\n> 在JSP中页面转发有两种情况：服务器内部跳转（forward）和客户端重定向（redirect）\\\\n\\\\n#### 转发到JSP页面\\\\n\\\\n**返回值是字符串：**\\\\n\\\\n默认使用服务器内部跳转（forward）。\\\\n\\\\n```return \\\\\\\"main\\\\\\\";```\\\\n\\\\n客户端重定向，在返回的字符串前加上\\\\\\\"redirect:/\\\\\\\"。\\\\n\\\\n```return \\\\\\\"redirect:/main.jsp\\\\\\\";```\\\\n\\\\n**使用ModelAndView：**\\\\n\\\\n默认使用服务器内部跳转（forward）。\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"main\\\\\\\");\\\\n```\\\\n希望重定向。\\\\n\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"redirect:/main.jsp\\\\\\\");\\\\n```\\\\n\\\\n\\\\n由于客户端重定向（redirect）相当于在浏览器重新发送请求，所以不能访问WEB-INF下的资源文件，而且也必须写资源文件后缀名，即.jsp，因为此时springmvc-config.xml文件的视图解析器设置的前缀和后缀都将无效。\\\\n\\\\n\\\\n#### 转发到控制器的请求处理方法\\\\n\\\\n**请求处理方法返回值是字符串：**\\\\n\\\\n```return \\\\\\\"forward:/main\\\\\\\";```\\\\n\\\\n```return \\\\\\\"redirect:/main\\\\\\\";```\\\\n\\\\n**返回值是ModelAndView：**\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"forward:/main\\\\\\\");\\\\n```\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"redirect:/main\\\\\\\");\\\\n```\\\\n\\\\n\\\\n\\\\n## @RequestParam注解\\\\n\\\\n> @RequestParam注解用于将指定的请求参数赋值给方法中的形参。\\\\n\\\\n请求处理方法参数的可选类型为Java基本数据类型和String。\\\\t\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/login\\\\\\\")\\\\npublic ModelAndView login(@RequestParam(\\\\\\\"loginname\\\\\\\") String loginname,\\\\n                         @RequestParam(\\\\\\\"password\\\\\\\") String password) {\\\\n    return ...;\\\\n}\\\\n```\\\\n\\\\n需要注意的是，如果请求中不 包含\\\\\\\"loginname\\\\\\\"参数，则将会产生异常！因此，如果不能保证存在loginname参数，建议使用：\\\\n\\\\n```@RequestParam(value=\\\\\\\"loginname\\\\\\\", required=false)```\\\\n\\\\n## @PathVariable注解\\\\n\\\\n> @PathVariable注解可以非常方便地获得请求URL中的动态参数。\\\\n>\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/pathVariableTest/{userId}\\\\\\\")\\\\npublic void pathVariableTest(@PathVariable Integer userId) {\\\\n    ...\\\\n}\\\\n```\\\\n\\\\n假如请求的URL为```\\\\\\\"http://localhost:8080/VariableTest/pathVariableTest/1\\\\\\\"```,则自动将URL中模板变量{userId}绑定到通过@PathVariable注解的同名参数上，即userId变量将被赋值为1.\\\\n\\\\n## @MatrixVariable注解\\\\n\\\\n> @MatrixVariable注解拓展了URL请求地址的功能。使用@MatrixVariable注解时多个变量可以使用\\\\\\\";\\\\\\\"（分号）分隔，该注解允许开发者进行多条件组合查询。\\\\n>\\\\n\\\\n示例代码\\\\n\\\\n```java\\\\n@GetMapping(value=\\\\\\\"/matrixVariableTest/{userId}\\\\\\\")\\\\npublic void matrixVariableTest(@PathVariable Integer userId,\\\\n                              @MatrixVariable(value=\\\\\\\"name\\\\\\\", pathVar=\\\\\\\"userId\\\\\\\") String name,\\\\n                              @MarixVariable(value=\\\\\\\"age\\\\\\\", pathVar=\\\\\\\"userId\\\\\\\") Integer age) {\\\\n    ...\\\\n}\\\\n```\\\\n\\\\n假如请求的URL为```\\\\\\\"http://localhost:8080/VariableTest/matrixVariableTest/1;name=jack;age=23\\\\\\\"```，则自动将URL中模板变量{usrId}绑定到通过@PathVariable注解的同名参数上，即userId变量将被赋值为1；通过@MatrixVariable注解绑定name变量和age变量，即name变量将被赋值为jack，age变量将被赋值为23。\\\\n\\\\n需要注意的是，@MatrixVariable注解功能在SpringMVC中默认不启用的，启用它需要设置```enable-matrix-variables=\\\\\\\"true\\\\\\\"```。\\\\n\\\\n```<mvc:annotation-driven enable-matrix-variables=\\\\\\\"true\\\\\\\"/>```\\\\n\\\\n## @CrossOrigin 注解\\\\n\\\\n> @CrossOrigin注解用于在SpringMVC中处理跨域请求。\\\\n\\\\n| 属性             | 类型            | 是否必要 | 说明                                               |\\\\n| ---------------- | --------------- | -------- | -------------------------------------------------- |\\\\n| allowCredentials | String          | 否       | 包含与请求的域相关的Cookie，使用时必须指定具体的域 |\\\\n| allowedeHeaders  | String[]        | 否       | 请求头中的请求列表                                 |\\\\n| exposedHeaders   | String[]        | 否       | 客户端允许方法的响应头列表                         |\\\\n| maxAge           | long            | 否       | 响应前的缓存最大有效时间，单位是秒                 |\\\\n| methods          | RequestMethod[] | 否       | 请求支持的方法，默认支持RequestMapping中设置的方法 |\\\\n| origins          | String[]        | 否       | 所有支持域的集合，如果没有定义，默认支持所有域     |\\\\n| value            | String[]        | 否       | 同origins属性一样                                  |\\\\n\\\\n\\\\n\\\\n## @RequestHeader 注解\\\\n\\\\n> @RequestHeader注解用于将请求的头信息数据映射到功能处理方法的参数上。\\\\n\\\\n@RequestHeader注解示例代码\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/requestHeaderTest\\\\\\\")\\\\npublic void requestHeaderTest(@RequestHeader(\\\\\\\"User-Agent\\\\\\\") String userAgent,\\\\n                             @RequestHeadr(value=\\\\\\\"Accept\\\\\\\") String[] accepts)\\\\n```\\\\n\\\\n以上配置将自动将请求头“User-Agent”的值赋到userAgent变量上，并将请求头“Accept”的值赋到accepts变量上。\\\\n\\\\n\\\\n\\\\n## @Cookie Value注解\\\\n\\\\n> @CookieValue注解用于将请求的Cookie数据映射到功能处理方法的参数上。\\\\n\\\\n@CookieValue注解示例代码\\\\n\\\\n```java\\\\n@ReqeustMapping(vcalue=\\\\\\\"/cookieValueTest\\\\\\\")\\\\npublic void cookieValueTest(\\\\n    @CookieValue(value=\\\\\\\"JSESSIONID\\\\\\\", defaultValue=\\\\\\\"\\\\\\\")String sessionId)\\\\n```\\\\n\\\\n​\\\\t以上配置会自动将Cookie中JSESSIONID的值设置到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。\\\\n\\\\n\\\\n\\\\n## @RequestAttribute注解\\\\n\\\\n> @RequestAttribbute注解用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于request作用域中的属性，将该属性转换到目标方法的参数。\\\\n\\\\n​\\\\t@RequestAttribute注解示例代码\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/attributeTest\\\\\\\")\\\\npublic void attributeTest(\\\\n\\\\t@RequestAttribute(value=\\\\\\\"username\\\\\\\") String username)\\\\n```\\\\n\\\\n以上代码会指定将request作用域中名为username的属性的值设置到username参数上。\\\\n\\\\n\\\\n\\\\n## @SessionAttribute注解\\\\n\\\\n> @SessionAttribute注解用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于session作用域中的属性，将该属性转换到目标方法的参数。\\\\n\\\\n​\\\\t@SessionAttribute注解示例代码\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/attributeTest\\\\\\\")\\\\npublic void attributeTest(\\\\n\\\\t\\\\t@SessionAttribute(value=\\\\\\\"username\\\\\\\") String username)\\\\n```\\\\n\\\\n​\\\\t以上代码会自动将session作用域中名为username的属性的值设置到username参数上。\\\\n\\\\n\\\\n\\\\n## @SessionAttributes注解\\\\n\\\\n> @SessionAttributes注解允许我们有选择的指定Model中的哪些属性转存到HttpSession对象当中。\\\\n\\\\n@SessionAttributes注解只能声明在类上，而不能声明在方法上。\\\\n\\\\n\\\\n\\\\n## @ModelAttribute注解\\\\n\\\\n> @ModelAttribute注解用于将请求参数绑定到对象。@ModelAttribute注解只支持一个属性value，类型为String，表示绑定的属性名称。\\\\n\\\\n被@ModelAttribute注解的方法会在Controller每个方法执行前被执行，因此在一个Controller被映射到多个URL时，要谨慎使用。\\\\n\\\\n@ModelAttribute注解示例代码\\\\n\\\\n```java\\\\n@Controller\\\\npublic class ModelAttribute1Controller {\\\\n        @ModelAttribute(\\\\\\\"loginname\\\\\\\")\\\\n        public String userModel1(@RequestParam(\\\\\\\"loginname\\\\\\\") String loginname) {\\\\n            return loginname;\\\\n        }\\\\n        @RequestMapping(value=\\\\\\\"/login1\\\\\\\")\\\\n        public String login1() {\\\\n            return \\\\\\\"result1\\\\\\\";\\\\n        }\\\\n}\\\\n```\\\\n\\\\n​\\\\t\\\\t在ModelAttribute1Controller类中除了@ReqesutMapping映射的login1方法之外，还提供了一个userModel1方法，该方法上有一个@ModelAttribute注解。此处@ModelAttribute注解默认的value值为“loginname”，用来指定model属性的名称，而model属性的值就是userModel1方法的返回值。被@ModelAttribute注解的userModel1方法会先于login1调用，它把请求参数loginname的值赋给loginname变量，并设置了一个属性loginname到Model中，而属性的值就时loginname变量的值。\\\\n\\\\n\\\\n\\\\n## @ReqeustBody注解\\\\n\\\\n> @RequestBody注解常用来处理Content-Type：不是application/x-www-form-urlencoded编码的内容，例如application/json、application/xml等。@RequestBody注解通过使用HandlerAdapter配置的HttpMessageConverters来解析JSON或XML数据，然后绑定到相应的Bean上。\\\\n\\\\n### HttpMessageConverter<T>接口\\\\n\\\\n> \\\\t负责将请求信息转换为一个对象（类型为T），并将对象（类型为T）绑定到请求方法的参数上或输出为响应信息。DIspatcherServlet默认已经装配了RequestMappingHandlerAdapter作为HandlerAdapter组件的实现类，即HttpMessageConverter由RequestMappingHandlerAdapter使用，将请求信息转换为对象，或将对象转换为响应信息。\\\\n\\\\nHttpMessageConverter<T>接口中定义了以下几个方法：\\\\n\\\\n- boolean **canRead**(Class<?> clazz, MediaType mediaType)\\\\n\\\\n- boolean **canWrite**(Class<?> clazz, MediaType mediaType)\\\\n\\\\n- List<MediaType> **getSupportedMediaTypes**()\\\\n\\\\n- T **read**(Class<? extends T> clazz, HttpInputMessage inputMessage)\\\\n\\\\n- void write(T t, MediaType contentType, HttpOutputMessage outputMessage)\\\\n\\\\n  String为HttpMessageConverter<T>提供了多个实现类，这些实现类组成了一个功能强大、用途广泛的信息转换家族。列举几个主要的：\\\\n\\\\n  - StringHttpMessageConverter。将请求信息转换为字符串。泛型T为String类型，可以读取所有媒体类(*/*)的请求信息，可通过设置supportMediaTypes属性指定媒体类型。响应信息的媒体类型为text/plain（即Content-Type的值）。 \\\\n  - **MappingJackson2HttpMessageConverter。利用Jackson开源类包读写JSON数据。泛型T为Object类型，可以读取application/json类型的数据，响应信息的类型为application/json。**\\\\n\\\\n\\\\n\\\\n### 转换JSON数据\\\\n\\\\n> \\\\t@RequestBody注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到Controller中方法的参数上。\\\\n\\\\n当前台页面使用GET或POST方式提交数据时，数据编码格式由请求头的ContentType指定。可以分为以下几种情况：\\\\n\\\\n- **application/x-www-form-urlencoded**。这种情况的数据@RequestParam、@ModelAttribute也可以处理，@RequestBody也可以处理。\\\\n- **multipart/form-data**。@RequestBody不能处理这种格式的数据。\\\\n- **application/json**、**application/xml**等格式的数据，必须使用@RequestBody来处理。\\\\n\\\\n\\\\n\\\\n### 自定义HttpMessageConverter接收JSON格式的数据\\\\n\\\\n配置文件：\\\\n\\\\n```xml\\\\n<!-- 配置fastjson中实现HttpMessageConverter接口的转换器 -->\\\\n<!-- FastJsonHttpMessageConverter是fastjson中实现HttpMessageConverter接口的类 -->\\\\n<bean id=\\\\\\\"fastJsonHttpMessageConverter\\\\\\\" class=\\\\\\\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\\\\\\\">\\\\n\\\\t<!-- 加入支持的媒体类型：返回contentType -->\\\\n    <property name=\\\\\\\"supportedMediaTypes\\\\\\\">\\\\n    \\\\t<list>\\\\n        \\\\t<!-- 这里顺序不能反，一定先写text/html，不然IE下会出现下载提示 -->\\\\n            <value>text/html;charset=UTF-8</value>\\\\n            <value>application/json;charset=UTF-8</value>\\\\n        </list>\\\\n    </property>\\\\n</bean>\\\\n```\\\\n\\\\n```<mvc:message-converters register=default=\\\\\\\"false\\\\\\\">```设置不使用默认的消息转换器。\\\\n\\\\n\\\\n\\\\n## @ResponseBody注解\\\\n\\\\n> @ResponseBody注解用于将Controller的请求处理方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。当返回的数据不是HTML标签的页面时，而是其他某种格式的数据时（如JSON、XML等）使用它。\\\\n\\\\n不走视图解析器。\\\\n\\\\n\\\\n\\\\n## @RestController注解\\\\n\\\\n> @RestController注解本身使用@Controller和@ResponseBody注解。使用了 @RestController注解的类会被看作一个Controller，而该类中所有使用@RequestMapping注解的方法都默认使用了@ResponseBody注解。\\\\n\\\\n\\\\n\\\\n## SpringMVC的异常处理\\\\n\\\\n1. 使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver。\\\\n2. 使用@ExceptionHandler注解实现局部异常处理或使用@ControllerAdvice注解实现统一异常处理\\\\n\\\\n### @ResponseStatus注解\\\\n\\\\n> @ResponseStatus注解，通常修饰的是一个异常类\\\\n\\\\n先声明一个自定义异常类，在自定义异常类上面加上@ResponseStatus注解，表示在系统运行时期，当抛出自定义异常的时候，使用@ResponseStatus注解中声明的value属性和reason属性将异常信息返回给客户端。\\\\n\\\\n示例代码\\\\n\\\\n```java\\\\n@ResponseStatus(reason=\\\\\\\"查询数据失败\\\\\\\")\\\\npublic class BookException extends RunTimeException{\\\\n}\\\\n\\\\n@Controller\\\\npublic class BookController{\\\\n    \\\\n    @GetMapping(\\\\\\\"/find\\\\\\\")\\\\n\\\\tpublic String find() throws Exception{\\\\n        try {\\\\n            int i = 5/0;\\\\n            return \\\\\\\"success\\\\\\\";\\\\n        } catch(Exception e) {\\\\n            throw new BookException();\\\\n        }\\\\n    }\\\\n\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n### @ExceptionHandler注解\\\\n\\\\n> @Exceptionhandler注解的作用对象为方法，并且运行时有效，value()可以指定异常类\\\\n\\\\n@ExceptionHandler注解的方法可以支持的参数除了HttpServletRequest、HttpServletRespnse等对象外，还支持一个异常参数，包括一般的异常或自定义异常。如果注解没有指定异常类，会默认进行映射。\\\\n\\\\n\\\\n\\\\n@ControllerAdvice注解\\\\n\\\\n> ControllerAdvice是一个控制器增强功能注解\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleStatus\\\":\\\"1\\\"}\"}', '127.0.0.1', '2019-08-01 15:54:15');
INSERT INTO `t_blog_log` VALUES (12, 'admin', '保存文章草稿', '132', 'com.blog.admin.controller.ArticleController.saveArticle()', '  data: {\"data\":\"{\\\"articleCoverImg\\\":[],\\\"articleTitle\\\":\\\"SpringMVC的文件上传下载和拦截器机制\\\",\\\"articleAuthor\\\":\\\"OIA\\\",\\\"isOwn\\\":true,\\\"articleFrom\\\":\\\"\\\",\\\"articleTag\\\":\\\"1\\\",\\\"articleClassify\\\":1,\\\"articleDec\\\":\\\"\\\",\\\"articleContent\\\":\\\"## 文件上传\\\\n\\\\n**必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这种情况下，浏览器才会把用户选择的文件二进制数据发送给服务器。**\\\\n\\\\n*一般使用Commons FileUpload组件*\\\\n\\\\n\\\\n\\\\nSpringMVC实现了一个MultipartResolver类：CommonsMultipartResolver，因此SpringMVC上传文件需要依赖Apache Commons FileUpload组件（commons-fileupload和commons-io）\\\\n\\\\n示例代码：\\\\n\\\\n前端：\\\\n\\\\n```html\\\\n<form action=\\\\\\\"upload\\\\\\\" enctype=\\\\\\\"multipart/form-data\\\\\\\" method=\\\\\\\"post\\\\\\\">\\\\n    <input type=\\\\\\\"file\\\\\\\" name=\\\\\\\"file\\\\\\\"/>\\\\n</form>\\\\n```\\\\n\\\\n后端：\\\\n\\\\n```java\\\\n@Controller\\\\npublic class FileUploadController{\\\\n    //上传文件会自动绑定到MultipartFile\\\\n    @PostMapping(\\\\\\\"/upload\\\\\\\")\\\\n    public String upload(HttpServletRequest request, \\\\n                        @RequestParam(\\\\\\\"file\\\\\\\") MultipartFile file) throw Exception {\\\\n        \\\\n        //如果文件不为空，写入上传路径\\\\n        if(!file.isEmpty()) {\\\\n            //上传路径\\\\n            String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n        \\\\t//上传文件名\\\\n            String filename = file.getOriginalFilename();\\\\n            File filepath = new File(path, filename);\\\\n        \\\\t//判断路径是否存在，不存在就创建一个\\\\n            if(!filepath.getParentFile().exists()) {\\\\n                filepath.getParentFile().mkdirs();\\\\n            }\\\\n            //将上传的文件保存到一个目标文件当中\\\\n            file.transferTo(new File(path+File.separator+filename));\\\\n        \\\\tSystem.out.println(\\\\\\\"上传文件的路径：\\\\\\\" + (path+File.separator+filename));\\\\n            return \\\\\\\"success\\\\\\\";\\\\n        } else {\\\\n            return \\\\\\\"error\\\\\\\";\\\\n        }\\\\n    }\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n### MultipartFile对象的常用方法\\\\n\\\\n- `byte[] getBytes()` ：获取文件数据\\\\n- `String getContentType()`： 获取文件MIME类型，如image/jpeg等\\\\n- `InputStream getInputStream()`： 获取文件流\\\\n- `String getName()`：获取表单中文件组件的名称\\\\n- `String getOriginalFilename()`： 获取上传文件的原名\\\\n- `long getSize()`： 获取文件的字节大小，单位为byte\\\\n- `boolean isEmpty()`： 是否有上传的文件\\\\n- `void transferTo(FIle dest)`：将上传的文件保存到一个目标文件中\\\\n\\\\nSpringMVC中默认没有装配MultipartResolver，如果要使用SpringMVC的文件上传功能，需要在上下文中配置。\\\\n\\\\n```xml\\\\n<!-- 文件上传配置 -->\\\\n<bean id=\\\\\\\"multipartResolver\\\\\\\" class=\\\\\\\"org.springframeword.web.multipart.commons.CommonsMultipartResolver\\\\\\\">\\\\n    <!-- 上传文件大小上限，单位是字节（10MB） -->\\\\n\\\\t<property name=\\\\\\\"maxUploadSize\\\\\\\">\\\\n        <value>10485760</value>\\\\n    </property>\\\\n    <!-- 请求的编码格式，必须和jsp的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\\\\n\\\\t<property name=\\\\\\\"defaultEncoding\\\\\\\">\\\\n    \\\\t<value>UTF-8</value>\\\\n    </property>\\\\n</bean>  \\\\n```\\\\n\\\\n\\\\n\\\\n## 文件下载\\\\n\\\\nSpringMVC提供了一个ResponseEntity类型，可以定义返回的BodyBuilder、HttpHeaders和HJttpStatus\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@GetMapping(\\\\\\\"/download\\\\\\\")\\\\npublic ResponseEntity<byte[]> download(HttpServletRequest request,\\\\n                                      @RequestParam(\\\\\\\"filename\\\\\\\") String filename,\\\\n                                      @RequestHeader(\\\\\\\"User-Agent\\\\\\\") String userAgent)\\\\nthrow Exception{\\\\n    //下载路径\\\\n    String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n    //构建file\\\\n    File file = new File(path + File.separator + filename);\\\\n    //ok=200状态码\\\\n    BodyBuilder builder = ResponseEntity.ok();\\\\n    //内容长度\\\\n    builder.contentLength(file.length());\\\\n    //applicaiton/octet-stream:二进制流数据\\\\n    builder.contentType(MediaType.APPLICATION_OCTET_STREAM);\\\\n    //使用URLDecoder.decode对文件名进行解码\\\\n    filename = URLEncoder.encode(filename, \\\\\\\"UTF-8\\\\\\\");\\\\n    //设置实际的响应文件名，告诉浏览器文件要以附件形式打开\\\\n    //不同的浏览器，处理方式不同，要根据浏览器版本进行区别判断\\\\n    if(userAgent.indexOf(\\\\\\\"MSIE\\\\\\\") > 0) {\\\\n        //如果是IE，只需要用UTF-8字符集进行URL编码即可\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename=\\\\\\\"+filename);\\\\n    } else {\\\\n        //而Firefox、Chrome等浏览器，则需要说明编码的字符集\\\\n        //注意filename后面有个*号，在UTF-8后面有两个单引号\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename*=UTF-8\'\'\\\\\\\"+filename);\\\\n    }\\\\n    return builer.body(FileUtils.readFileToByteArray(file));\\\\n}\\\\n```\\\\n\\\\ndownload处理方法接收到页面传递的文件名filename后，使用Apache Commons FileUpload组件的FileUtils读取项目的images文件夹下的该文件，并将其构建成ResponseEntity对象返回给客户端下载。\\\\n\\\\n\\\\n\\\\n## 拦截器\\\\n\\\\n> Interceptor拦截器，它的主要功能是拦截用户的请求并进行相应的处理。比如用户权限验证，判断用户是否已经登录等。\\\\n\\\\n### HandlerInterceptor接口\\\\n\\\\nSpringMVC中的Interceptor拦截器拦截请求是通过实现HandlerInterceptor接口来完成的，在SpringMVC中定义一个Interceptor拦截器，通常在要定义的Interceptor拦截器类中实现Spring的HandlerInteceptor接口，或者继承抽象类HandlerInterceptorAdapter。\\\\n\\\\nHandlerInterceptor接口中定义了三个方法：\\\\n\\\\n- **boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)**：在请求处理前调用，当返回的是false则请求结束，当返回的是true，继续执行。\\\\n- **void postHandle(HttpServletReqeust request, HttpServletResponse response, Object handler, ModelAndView mv)**：当前请求被处理之后，也就是Controller方法被调用之后执行，但是会在DispatcherServlet进行视图返回渲染之前被调用，所以可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。\\\\n- **void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object hadnler, Exception exception)**：将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图后执行。主要进行资源的清理。\\\\n\\\\n示例代码：\\\\n\\\\n设计一个拦截器验证用户是否登录，没有登录，不可以访问除登录外页面和登录请求外的Controller\\\\n\\\\n```java\\\\n/**\\\\n * 拦截器必须实现HandlerInterceptor接口\\\\n */\\\\npublic class AuthorizationInterceptor implements HandlerInterceptor {\\\\n\\\\n    //不拦截\\\\\\\"/loginForm\\\\\\\" 和\\\\\\\"/login\\\\\\\"请求\\\\n    private static final String[] IGNORE_URI = {\\\\\\\"/loginForm\\\\\\\", \\\\\\\"/login\\\\\\\"};\\\\n\\\\n    /**\\\\n     * preHandle方法是进行处理器拦截用的，该方法将在Controller处理之前调用\\\\n     * 该方法的返回值为true时拦截器才会继续往下执行，该方法的返回值为false时，整个请求就结束了\\\\n     */\\\\n    @Override\\\\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor preHandle...\\\\\\\");\\\\n        //flag判断用户是否登录\\\\n        boolean flag  = false;\\\\n        //获取请求路径\\\\n        String servletPath = request.getServletPath();\\\\n        //判断请求是否需要拦截\\\\n        for (String s : IGNORE_URI) {\\\\n            if (servletPath.contains(s)) {\\\\n                flag = true;\\\\n                break;\\\\n            }\\\\n        }\\\\n        //拦截请求\\\\n        if (!flag) {\\\\n            //1、获取session中的用户\\\\n            User user = request.getSession().getAttribute(\\\\\\\"user\\\\\\\");\\\\n            //2、判断用户是否已经登录\\\\n            if (user == null) {\\\\n                System.out.println(\\\\\\\"用户没有登录\\\\\\\");\\\\n                request.setAttribute(\\\\\\\"message\\\\\\\", \\\\\\\"请先登录\\\\\\\");\\\\n                request.getRequestDispatcher(\\\\\\\"loginForm\\\\\\\").forward(request, response);\\\\n            } else {\\\\n                System.out.println(\\\\\\\"用户登录了，可以访问\\\\\\\");\\\\n                flag = true;\\\\n            }\\\\n        }\\\\n        return false;\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在Controller的调用之后执行，方法中可以对ModelAndView进行操作\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor postHandle...\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在整个请求完成之后执行，主要作用是清理资源\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor afterCompletion...\\\\\\\");\\\\n    }\\\\n}\\\\n\\\\n```\\\\n\\\\n在springmvc-config.xml文件中配置拦截器\\\\n\\\\n```xml\\\\n<!-- spring mvc拦截器配置 -->\\\\n<mvc:interceptors>\\\\n\\\\t<mvc:interceptor>\\\\n\\\\t\\\\t<!-- 拦截所有请求 -->\\\\n        <mvc:mapping path=\\\\\\\"/\\\\\\\"/>\\\\n        <!-- 使用bean顶一个Interceptor -->\\\\n        <bean class=\\\\\\\"org.fkit.interceptor.AuthorizationInterceptor\\\\\\\"/>\\\\n    </mvc:interceptor>\\\\n</mvc:interceptors>\\\\n```\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleStatus\\\":\\\"0\\\"}\"}', '127.0.0.1', '2019-08-01 15:55:45');
INSERT INTO `t_blog_log` VALUES (13, 'admin', '添加标签', '60', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"Spring\\\"}\"}', '127.0.0.1', '2019-08-01 15:55:54');
INSERT INTO `t_blog_log` VALUES (14, 'admin', '修改文章', '126', 'com.blog.admin.controller.ArticleController.editArticle()', '  data: {\"data\":\"{\\\"articleAuthor\\\":\\\"OIA\\\",\\\"articleClassify\\\":1,\\\"articleClassifyID\\\":\\\"1\\\",\\\"articleComment\\\":\\\"\\\",\\\"articleContent\\\":\\\"## 文件上传\\\\n\\\\n**必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这种情况下，浏览器才会把用户选择的文件二进制数据发送给服务器。**\\\\n\\\\n*一般使用Commons FileUpload组件*\\\\n\\\\n\\\\n\\\\nSpringMVC实现了一个MultipartResolver类：CommonsMultipartResolver，因此SpringMVC上传文件需要依赖Apache Commons FileUpload组件（commons-fileupload和commons-io）\\\\n\\\\n示例代码：\\\\n\\\\n前端：\\\\n\\\\n```html\\\\n<form action=\\\\\\\"upload\\\\\\\" enctype=\\\\\\\"multipart/form-data\\\\\\\" method=\\\\\\\"post\\\\\\\">\\\\n    <input type=\\\\\\\"file\\\\\\\" name=\\\\\\\"file\\\\\\\"/>\\\\n</form>\\\\n```\\\\n\\\\n后端：\\\\n\\\\n```java\\\\n@Controller\\\\npublic class FileUploadController{\\\\n    //上传文件会自动绑定到MultipartFile\\\\n    @PostMapping(\\\\\\\"/upload\\\\\\\")\\\\n    public String upload(HttpServletRequest request, \\\\n                        @RequestParam(\\\\\\\"file\\\\\\\") MultipartFile file) throw Exception {\\\\n        \\\\n        //如果文件不为空，写入上传路径\\\\n        if(!file.isEmpty()) {\\\\n            //上传路径\\\\n            String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n        \\\\t//上传文件名\\\\n            String filename = file.getOriginalFilename();\\\\n            File filepath = new File(path, filename);\\\\n        \\\\t//判断路径是否存在，不存在就创建一个\\\\n            if(!filepath.getParentFile().exists()) {\\\\n                filepath.getParentFile().mkdirs();\\\\n            }\\\\n            //将上传的文件保存到一个目标文件当中\\\\n            file.transferTo(new File(path+File.separator+filename));\\\\n        \\\\tSystem.out.println(\\\\\\\"上传文件的路径：\\\\\\\" + (path+File.separator+filename));\\\\n            return \\\\\\\"success\\\\\\\";\\\\n        } else {\\\\n            return \\\\\\\"error\\\\\\\";\\\\n        }\\\\n    }\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n### MultipartFile对象的常用方法\\\\n\\\\n- `byte[] getBytes()` ：获取文件数据\\\\n- `String getContentType()`： 获取文件MIME类型，如image/jpeg等\\\\n- `InputStream getInputStream()`： 获取文件流\\\\n- `String getName()`：获取表单中文件组件的名称\\\\n- `String getOriginalFilename()`： 获取上传文件的原名\\\\n- `long getSize()`： 获取文件的字节大小，单位为byte\\\\n- `boolean isEmpty()`： 是否有上传的文件\\\\n- `void transferTo(FIle dest)`：将上传的文件保存到一个目标文件中\\\\n\\\\nSpringMVC中默认没有装配MultipartResolver，如果要使用SpringMVC的文件上传功能，需要在上下文中配置。\\\\n\\\\n```xml\\\\n<!-- 文件上传配置 -->\\\\n<bean id=\\\\\\\"multipartResolver\\\\\\\" class=\\\\\\\"org.springframeword.web.multipart.commons.CommonsMultipartResolver\\\\\\\">\\\\n    <!-- 上传文件大小上限，单位是字节（10MB） -->\\\\n\\\\t<property name=\\\\\\\"maxUploadSize\\\\\\\">\\\\n        <value>10485760</value>\\\\n    </property>\\\\n    <!-- 请求的编码格式，必须和jsp的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\\\\n\\\\t<property name=\\\\\\\"defaultEncoding\\\\\\\">\\\\n    \\\\t<value>UTF-8</value>\\\\n    </property>\\\\n</bean>  \\\\n```\\\\n\\\\n\\\\n\\\\n## 文件下载\\\\n\\\\nSpringMVC提供了一个ResponseEntity类型，可以定义返回的BodyBuilder、HttpHeaders和HJttpStatus\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@GetMapping(\\\\\\\"/download\\\\\\\")\\\\npublic ResponseEntity<byte[]> download(HttpServletRequest request,\\\\n                                      @RequestParam(\\\\\\\"filename\\\\\\\") String filename,\\\\n                                      @RequestHeader(\\\\\\\"User-Agent\\\\\\\") String userAgent)\\\\nthrow Exception{\\\\n    //下载路径\\\\n    String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n    //构建file\\\\n    File file = new File(path + File.separator + filename);\\\\n    //ok=200状态码\\\\n    BodyBuilder builder = ResponseEntity.ok();\\\\n    //内容长度\\\\n    builder.contentLength(file.length());\\\\n    //applicaiton/octet-stream:二进制流数据\\\\n    builder.contentType(MediaType.APPLICATION_OCTET_STREAM);\\\\n    //使用URLDecoder.decode对文件名进行解码\\\\n    filename = URLEncoder.encode(filename, \\\\\\\"UTF-8\\\\\\\");\\\\n    //设置实际的响应文件名，告诉浏览器文件要以附件形式打开\\\\n    //不同的浏览器，处理方式不同，要根据浏览器版本进行区别判断\\\\n    if(userAgent.indexOf(\\\\\\\"MSIE\\\\\\\") > 0) {\\\\n        //如果是IE，只需要用UTF-8字符集进行URL编码即可\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename=\\\\\\\"+filename);\\\\n    } else {\\\\n        //而Firefox、Chrome等浏览器，则需要说明编码的字符集\\\\n        //注意filename后面有个*号，在UTF-8后面有两个单引号\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename*=UTF-8\'\'\\\\\\\"+filename);\\\\n    }\\\\n    return builer.body(FileUtils.readFileToByteArray(file));\\\\n}\\\\n```\\\\n\\\\ndownload处理方法接收到页面传递的文件名filename后，使用Apache Commons FileUpload组件的FileUtils读取项目的images文件夹下的该文件，并将其构建成ResponseEntity对象返回给客户端下载。\\\\n\\\\n\\\\n\\\\n## 拦截器\\\\n\\\\n> Interceptor拦截器，它的主要功能是拦截用户的请求并进行相应的处理。比如用户权限验证，判断用户是否已经登录等。\\\\n\\\\n### HandlerInterceptor接口\\\\n\\\\nSpringMVC中的Interceptor拦截器拦截请求是通过实现HandlerInterceptor接口来完成的，在SpringMVC中定义一个Interceptor拦截器，通常在要定义的Interceptor拦截器类中实现Spring的HandlerInteceptor接口，或者继承抽象类HandlerInterceptorAdapter。\\\\n\\\\nHandlerInterceptor接口中定义了三个方法：\\\\n\\\\n- **boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)**：在请求处理前调用，当返回的是false则请求结束，当返回的是true，继续执行。\\\\n- **void postHandle(HttpServletReqeust request, HttpServletResponse response, Object handler, ModelAndView mv)**：当前请求被处理之后，也就是Controller方法被调用之后执行，但是会在DispatcherServlet进行视图返回渲染之前被调用，所以可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。\\\\n- **void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object hadnler, Exception exception)**：将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图后执行。主要进行资源的清理。\\\\n\\\\n示例代码：\\\\n\\\\n设计一个拦截器验证用户是否登录，没有登录，不可以访问除登录外页面和登录请求外的Controller\\\\n\\\\n```java\\\\n/**\\\\n * 拦截器必须实现HandlerInterceptor接口\\\\n */\\\\npublic class AuthorizationInterceptor implements HandlerInterceptor {\\\\n\\\\n    //不拦截\\\\\\\"/loginForm\\\\\\\" 和\\\\\\\"/login\\\\\\\"请求\\\\n    private static final String[] IGNORE_URI = {\\\\\\\"/loginForm\\\\\\\", \\\\\\\"/login\\\\\\\"};\\\\n\\\\n    /**\\\\n     * preHandle方法是进行处理器拦截用的，该方法将在Controller处理之前调用\\\\n     * 该方法的返回值为true时拦截器才会继续往下执行，该方法的返回值为false时，整个请求就结束了\\\\n     */\\\\n    @Override\\\\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor preHandle...\\\\\\\");\\\\n        //flag判断用户是否登录\\\\n        boolean flag  = false;\\\\n        //获取请求路径\\\\n        String servletPath = request.getServletPath();\\\\n        //判断请求是否需要拦截\\\\n        for (String s : IGNORE_URI) {\\\\n            if (servletPath.contains(s)) {\\\\n                flag = true;\\\\n                break;\\\\n            }\\\\n        }\\\\n        //拦截请求\\\\n        if (!flag) {\\\\n            //1、获取session中的用户\\\\n            User user = request.getSession().getAttribute(\\\\\\\"user\\\\\\\");\\\\n            //2、判断用户是否已经登录\\\\n            if (user == null) {\\\\n                System.out.println(\\\\\\\"用户没有登录\\\\\\\");\\\\n                request.setAttribute(\\\\\\\"message\\\\\\\", \\\\\\\"请先登录\\\\\\\");\\\\n                request.getRequestDispatcher(\\\\\\\"loginForm\\\\\\\").forward(request, response);\\\\n            } else {\\\\n                System.out.println(\\\\\\\"用户登录了，可以访问\\\\\\\");\\\\n                flag = true;\\\\n            }\\\\n        }\\\\n        return false;\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在Controller的调用之后执行，方法中可以对ModelAndView进行操作\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor postHandle...\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在整个请求完成之后执行，主要作用是清理资源\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor afterCompletion...\\\\\\\");\\\\n    }\\\\n}\\\\n\\\\n```\\\\n\\\\n在springmvc-config.xml文件中配置拦截器\\\\n\\\\n```xml\\\\n<!-- spring mvc拦截器配置 -->\\\\n<mvc:interceptors>\\\\n\\\\t<mvc:interceptor>\\\\n\\\\t\\\\t<!-- 拦截所有请求 -->\\\\n        <mvc:mapping path=\\\\\\\"/\\\\\\\"/>\\\\n        <!-- 使用bean顶一个Interceptor -->\\\\n        <bean class=\\\\\\\"org.fkit.interceptor.AuthorizationInterceptor\\\\\\\"/>\\\\n    </mvc:interceptor>\\\\n</mvc:interceptors>\\\\n```\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleCoverImg\\\":[],\\\"articleCreationTime\\\":\\\"\\\",\\\"articleDec\\\":\\\"springmvc中文件的长传和下载，以及springmvc中如何应用拦截器\\\",\\\"articleFrom\\\":\\\"\\\",\\\"articleLastUpdateTime\\\":\\\"\\\",\\\"articleStatus\\\":\\\"1\\\",\\\"articleTag\\\":\\\"1\\\",\\\"articleTagID\\\":\\\"1\\\",\\\"articleTitle\\\":\\\"SpringMVC的文件上传下载和拦截器机制\\\",\\\"articleView\\\":\\\"\\\",\\\"id\\\":2,\\\"isDelete\\\":\\\"\\\",\\\"isMain\\\":\\\"\\\",\\\"isOwn\\\":true,\\\"isRec\\\":\\\"\\\"}\"}', '127.0.0.1', '2019-08-01 15:57:53');
INSERT INTO `t_blog_log` VALUES (15, 'admin', '修改文章', '86', 'com.blog.admin.controller.ArticleController.editArticle()', '  data: {\"data\":\"{\\\"articleAuthor\\\":\\\"OIA\\\",\\\"articleClassify\\\":1,\\\"articleClassifyID\\\":\\\"1\\\",\\\"articleComment\\\":\\\"\\\",\\\"articleContent\\\":\\\"## 文件上传\\\\n\\\\n**必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这种情况下，浏览器才会把用户选择的文件二进制数据发送给服务器。**\\\\n\\\\n*一般使用Commons FileUpload组件*\\\\n\\\\n\\\\n\\\\nSpringMVC实现了一个MultipartResolver类：CommonsMultipartResolver，因此SpringMVC上传文件需要依赖Apache Commons FileUpload组件（commons-fileupload和commons-io）\\\\n\\\\n示例代码：\\\\n\\\\n前端：\\\\n\\\\n```html\\\\n<form action=\\\\\\\"upload\\\\\\\" enctype=\\\\\\\"multipart/form-data\\\\\\\" method=\\\\\\\"post\\\\\\\">\\\\n    <input type=\\\\\\\"file\\\\\\\" name=\\\\\\\"file\\\\\\\"/>\\\\n</form>\\\\n```\\\\n\\\\n后端：\\\\n\\\\n```java\\\\n@Controller\\\\npublic class FileUploadController{\\\\n    //上传文件会自动绑定到MultipartFile\\\\n    @PostMapping(\\\\\\\"/upload\\\\\\\")\\\\n    public String upload(HttpServletRequest request, \\\\n                        @RequestParam(\\\\\\\"file\\\\\\\") MultipartFile file) throw Exception {\\\\n        \\\\n        //如果文件不为空，写入上传路径\\\\n        if(!file.isEmpty()) {\\\\n            //上传路径\\\\n            String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n        \\\\t//上传文件名\\\\n            String filename = file.getOriginalFilename();\\\\n            File filepath = new File(path, filename);\\\\n        \\\\t//判断路径是否存在，不存在就创建一个\\\\n            if(!filepath.getParentFile().exists()) {\\\\n                filepath.getParentFile().mkdirs();\\\\n            }\\\\n            //将上传的文件保存到一个目标文件当中\\\\n            file.transferTo(new File(path+File.separator+filename));\\\\n        \\\\tSystem.out.println(\\\\\\\"上传文件的路径：\\\\\\\" + (path+File.separator+filename));\\\\n            return \\\\\\\"success\\\\\\\";\\\\n        } else {\\\\n            return \\\\\\\"error\\\\\\\";\\\\n        }\\\\n    }\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n### MultipartFile对象的常用方法\\\\n\\\\n- `byte[] getBytes()` ：获取文件数据\\\\n- `String getContentType()`： 获取文件MIME类型，如image/jpeg等\\\\n- `InputStream getInputStream()`： 获取文件流\\\\n- `String getName()`：获取表单中文件组件的名称\\\\n- `String getOriginalFilename()`： 获取上传文件的原名\\\\n- `long getSize()`： 获取文件的字节大小，单位为byte\\\\n- `boolean isEmpty()`： 是否有上传的文件\\\\n- `void transferTo(FIle dest)`：将上传的文件保存到一个目标文件中\\\\n\\\\nSpringMVC中默认没有装配MultipartResolver，如果要使用SpringMVC的文件上传功能，需要在上下文中配置。\\\\n\\\\n```xml\\\\n<!-- 文件上传配置 -->\\\\n<bean id=\\\\\\\"multipartResolver\\\\\\\" class=\\\\\\\"org.springframeword.web.multipart.commons.CommonsMultipartResolver\\\\\\\">\\\\n    <!-- 上传文件大小上限，单位是字节（10MB） -->\\\\n\\\\t<property name=\\\\\\\"maxUploadSize\\\\\\\">\\\\n        <value>10485760</value>\\\\n    </property>\\\\n    <!-- 请求的编码格式，必须和jsp的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\\\\n\\\\t<property name=\\\\\\\"defaultEncoding\\\\\\\">\\\\n    \\\\t<value>UTF-8</value>\\\\n    </property>\\\\n</bean>  \\\\n```\\\\n\\\\n\\\\n\\\\n## 文件下载\\\\n\\\\nSpringMVC提供了一个ResponseEntity类型，可以定义返回的BodyBuilder、HttpHeaders和HJttpStatus\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@GetMapping(\\\\\\\"/download\\\\\\\")\\\\npublic ResponseEntity<byte[]> download(HttpServletRequest request,\\\\n                                      @RequestParam(\\\\\\\"filename\\\\\\\") String filename,\\\\n                                      @RequestHeader(\\\\\\\"User-Agent\\\\\\\") String userAgent)\\\\nthrow Exception{\\\\n    //下载路径\\\\n    String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n    //构建file\\\\n    File file = new File(path + File.separator + filename);\\\\n    //ok=200状态码\\\\n    BodyBuilder builder = ResponseEntity.ok();\\\\n    //内容长度\\\\n    builder.contentLength(file.length());\\\\n    //applicaiton/octet-stream:二进制流数据\\\\n    builder.contentType(MediaType.APPLICATION_OCTET_STREAM);\\\\n    //使用URLDecoder.decode对文件名进行解码\\\\n    filename = URLEncoder.encode(filename, \\\\\\\"UTF-8\\\\\\\");\\\\n    //设置实际的响应文件名，告诉浏览器文件要以附件形式打开\\\\n    //不同的浏览器，处理方式不同，要根据浏览器版本进行区别判断\\\\n    if(userAgent.indexOf(\\\\\\\"MSIE\\\\\\\") > 0) {\\\\n        //如果是IE，只需要用UTF-8字符集进行URL编码即可\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename=\\\\\\\"+filename);\\\\n    } else {\\\\n        //而Firefox、Chrome等浏览器，则需要说明编码的字符集\\\\n        //注意filename后面有个*号，在UTF-8后面有两个单引号\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename*=UTF-8\'\'\\\\\\\"+filename);\\\\n    }\\\\n    return builer.body(FileUtils.readFileToByteArray(file));\\\\n}\\\\n```\\\\n\\\\ndownload处理方法接收到页面传递的文件名filename后，使用Apache Commons FileUpload组件的FileUtils读取项目的images文件夹下的该文件，并将其构建成ResponseEntity对象返回给客户端下载。\\\\n\\\\n\\\\n\\\\n## 拦截器\\\\n\\\\n> Interceptor拦截器，它的主要功能是拦截用户的请求并进行相应的处理。比如用户权限验证，判断用户是否已经登录等。\\\\n\\\\n### HandlerInterceptor接口\\\\n\\\\nSpringMVC中的Interceptor拦截器拦截请求是通过实现HandlerInterceptor接口来完成的，在SpringMVC中定义一个Interceptor拦截器，通常在要定义的Interceptor拦截器类中实现Spring的HandlerInteceptor接口，或者继承抽象类HandlerInterceptorAdapter。\\\\n\\\\nHandlerInterceptor接口中定义了三个方法：\\\\n\\\\n- **boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)**：在请求处理前调用，当返回的是false则请求结束，当返回的是true，继续执行。\\\\n- **void postHandle(HttpServletReqeust request, HttpServletResponse response, Object handler, ModelAndView mv)**：当前请求被处理之后，也就是Controller方法被调用之后执行，但是会在DispatcherServlet进行视图返回渲染之前被调用，所以可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。\\\\n- **void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object hadnler, Exception exception)**：将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图后执行。主要进行资源的清理。\\\\n\\\\n示例代码：\\\\n\\\\n设计一个拦截器验证用户是否登录，没有登录，不可以访问除登录外页面和登录请求外的Controller\\\\n\\\\n```java\\\\n/**\\\\n * 拦截器必须实现HandlerInterceptor接口\\\\n */\\\\npublic class AuthorizationInterceptor implements HandlerInterceptor {\\\\n\\\\n    //不拦截\\\\\\\"/loginForm\\\\\\\" 和\\\\\\\"/login\\\\\\\"请求\\\\n    private static final String[] IGNORE_URI = {\\\\\\\"/loginForm\\\\\\\", \\\\\\\"/login\\\\\\\"};\\\\n\\\\n    /**\\\\n     * preHandle方法是进行处理器拦截用的，该方法将在Controller处理之前调用\\\\n     * 该方法的返回值为true时拦截器才会继续往下执行，该方法的返回值为false时，整个请求就结束了\\\\n     */\\\\n    @Override\\\\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor preHandle...\\\\\\\");\\\\n        //flag判断用户是否登录\\\\n        boolean flag  = false;\\\\n        //获取请求路径\\\\n        String servletPath = request.getServletPath();\\\\n        //判断请求是否需要拦截\\\\n        for (String s : IGNORE_URI) {\\\\n            if (servletPath.contains(s)) {\\\\n                flag = true;\\\\n                break;\\\\n            }\\\\n        }\\\\n        //拦截请求\\\\n        if (!flag) {\\\\n            //1、获取session中的用户\\\\n            User user = request.getSession().getAttribute(\\\\\\\"user\\\\\\\");\\\\n            //2、判断用户是否已经登录\\\\n            if (user == null) {\\\\n                System.out.println(\\\\\\\"用户没有登录\\\\\\\");\\\\n                request.setAttribute(\\\\\\\"message\\\\\\\", \\\\\\\"请先登录\\\\\\\");\\\\n                request.getRequestDispatcher(\\\\\\\"loginForm\\\\\\\").forward(request, response);\\\\n            } else {\\\\n                System.out.println(\\\\\\\"用户登录了，可以访问\\\\\\\");\\\\n                flag = true;\\\\n            }\\\\n        }\\\\n        return false;\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在Controller的调用之后执行，方法中可以对ModelAndView进行操作\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor postHandle...\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在整个请求完成之后执行，主要作用是清理资源\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor afterCompletion...\\\\\\\");\\\\n    }\\\\n}\\\\n\\\\n```\\\\n\\\\n在springmvc-config.xml文件中配置拦截器\\\\n\\\\n```xml\\\\n<!-- spring mvc拦截器配置 -->\\\\n<mvc:interceptors>\\\\n\\\\t<mvc:interceptor>\\\\n\\\\t\\\\t<!-- 拦截所有请求 -->\\\\n        <mvc:mapping path=\\\\\\\"/\\\\\\\"/>\\\\n        <!-- 使用bean顶一个Interceptor -->\\\\n        <bean class=\\\\\\\"org.fkit.interceptor.AuthorizationInterceptor\\\\\\\"/>\\\\n    </mvc:interceptor>\\\\n</mvc:interceptors>\\\\n```\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleCoverImg\\\":[{\\\"name\\\":\\\"20190801160003.jpg\\\",\\\"url\\\":\\\"http://lsblog.vip/coverImg/20190801160003.jpg\\\",\\\"uid\\\":1564646404409,\\\"status\\\":\\\"success\\\"}],\\\"articleCreationTime\\\":\\\"\\\",\\\"articleDec\\\":\\\"springmvc中文件的长传和下载，以及springmvc中如何应用拦截器\\\",\\\"articleFrom\\\":\\\"\\\",\\\"articleLastUpdateTime\\\":\\\"\\\",\\\"articleStatus\\\":\\\"1\\\",\\\"articleTag\\\":\\\"1\\\",\\\"articleTagID\\\":\\\"1\\\",\\\"articleTitle\\\":\\\"SpringMVC的文件上传下载和拦截器机制\\\",\\\"articleView\\\":\\\"\\\",\\\"id\\\":2,\\\"isDelete\\\":\\\"\\\",\\\"isMain\\\":\\\"\\\",\\\"isOwn\\\":true,\\\"isRec\\\":\\\"\\\"}\"}', '127.0.0.1', '2019-08-01 16:00:08');
INSERT INTO `t_blog_log` VALUES (16, 'admin', '添加标签', '168', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"MyBatis\\\"}\"}', '127.0.0.1', '2019-08-01 16:01:46');
INSERT INTO `t_blog_log` VALUES (17, 'admin', '添加标签', '57', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"插件\\\"}\"}', '127.0.0.1', '2019-08-01 16:01:57');
INSERT INTO `t_blog_log` VALUES (18, 'admin', '发表文章', '86', 'com.blog.admin.controller.ArticleController.addArticle()', '  data: {\"data\":\"{\\\"articleCoverImg\\\":[{\\\"name\\\":\\\"20190801160341.png\\\",\\\"url\\\":\\\"http://lsblog.vip/coverImg/20190801160341.png\\\",\\\"uid\\\":1564646621991,\\\"status\\\":\\\"success\\\"}],\\\"articleTitle\\\":\\\"pageHelper插件\\\",\\\"articleAuthor\\\":\\\"OIA\\\",\\\"isOwn\\\":true,\\\"articleFrom\\\":\\\"\\\",\\\"articleTag\\\":\\\"6,7\\\",\\\"articleClassify\\\":1,\\\"articleDec\\\":\\\"关于mybatis的pagehelper插件的使用，以及在使用中遇到的问题\\\",\\\"articleContent\\\":\\\"# pageHelper插件的使用\\\\n\\\\n1. 导入pageHelper的jar包\\\\n\\\\n   ```xml\\\\n   <dependency>\\\\n         <groupId>com.github.pagehelper</groupId>\\\\n         <artifactId>pagehelper</artifactId>\\\\n         <version>4.1.4</version>\\\\n   </dependency>\\\\n   ```\\\\n\\\\n2. 在mybatis.xml文件中配置\\\\n\\\\n   ```xml\\\\n   <plugins>\\\\n         <plugin interceptor=\\\\\\\"com.github.pagehelper.PageHelper\\\\\\\">\\\\n             <property name=\\\\\\\"dialect\\\\\\\" value=\\\\\\\"mysql\\\\\\\"/>\\\\n         </plugin>\\\\n   </plugins>\\\\n   ```\\\\n\\\\n3. 写一个sql语句，返回的结果为list\\\\n\\\\n   ```sql\\\\n   select * from worker order by wno\\\\n   ```\\\\n\\\\n4. service层\\\\n\\\\n   ```java\\\\n   public List<Worker> getAllWorkers() {\\\\n         List<Worker> allWorkers = managerDao.getAllWorkers();\\\\n         return allWorkers;\\\\n   }\\\\n   ```\\\\n\\\\n5. controller层\\\\n\\\\n   ```java\\\\n   @RequestMapping(value = \\\\\\\"/manager\\\\\\\")\\\\n       public ModelAndView manager(HttpServletRequest request,\\\\n                                   @RequestParam(required = true, defaultValue = \\\\\\\"1\\\\\\\") Integer pageIndex) {\\\\n            ModelAndView mav = new ModelAndView();\\\\n           //获取第pageIndex页，每页10条数据\\\\n           PageHelper.startPage(pageIndex, 10);\\\\n         \\\\t//紧跟着第一个select方法会被分页，后面的不会被分页，除非再次调用PageHelper.startPage\\\\n           List<Worker> allWorkers = managerService.getAllWorkers();\\\\n           //用pageInfo对结果进行包装\\\\n           PageInfo<Worker> pagehelper = new PageInfo<Worker>(allWorkers);\\\\n           mav.addObject(\\\\\\\"page\\\\\\\", pagehelper);\\\\n           mav.addObject(\\\\\\\"workers\\\\\\\", allWorkers);\\\\n           mav.setViewName(\\\\\\\"manager\\\\\\\");\\\\n           return mav;\\\\n       }\\\\n   ```\\\\n\\\\n6. pageInfo类，pegeInfo是插件里面的类，包含了非常全面的分页属性\\\\n\\\\n   在使用pageInfo这个类的时候，要将查询出来的list放到pageInfo中去\\\\n\\\\n   ```java\\\\n   List<Worker> allWorkers = managerService.getAllWorkers();\\\\n   PageInfo<Worker> pagehelper = new PageInfo<Worker>(allWorkers);\\\\n   ```\\\\n\\\\n   ```java\\\\n   //当前页\\\\n   private int pageNum;\\\\n   //每页的数量\\\\n   private int pageSize;\\\\n   //当前页的数量\\\\n   private int size;\\\\n   //排序\\\\n   private String orderBy;\\\\n   \\\\n   //由于startRow和endRow不常用，这里说个具体的用法\\\\n   //可以在页面中\\\\\\\"显示startRow到endRow 共size条数据\\\\\\\"\\\\n   \\\\n   //当前页面第一个元素在数据库中的行号\\\\n   private int startRow;\\\\n   //当前页面最后一个元素在数据库中的行号\\\\n   private int endRow;\\\\n   //总记录数\\\\n   private long total;\\\\n   //总页数\\\\n   private int pages;\\\\n   //结果集\\\\n   private List<T> list;\\\\n   \\\\n   //第一页\\\\n   private int firstPage;\\\\n   //前一页\\\\n   private int prePage;\\\\n   //下一页\\\\n   private int nextPage;\\\\n   //最后一页\\\\n   private int lastPage;\\\\n   \\\\n   //是否为第一页\\\\n   private boolean isFirstPage = false;\\\\n   //是否为最后一页\\\\n   private boolean isLastPage = false;\\\\n   //是否有前一页\\\\n   private boolean hasPreviousPage = false;\\\\n   //是否有下一页\\\\n   private boolean hasNextPage = false;\\\\n   //导航页码数\\\\n   private int navigatePages;\\\\n   //所有导航页号\\\\n   private int[] navigatepageNums;\\\\n   ```\\\\n\\\\n7. jsp页面\\\\n\\\\n   ```jsp\\\\n   <c:if test=\\\\\\\"${!page.isIsFirstPage()}\\\\\\\">\\\\n   \\\\t<li><a href=\\\\\\\"manager?pageIndex=1\\\\\\\">首页</a></li>\\\\n   \\\\t<li><a href=\\\\\\\"manager?pageIndex=${page.prePage}\\\\\\\">上一页</a></li>\\\\n   </c:if>\\\\n   <c:forEach begin=\\\\\\\"1\\\\\\\" end=\\\\\\\"${page.pages}\\\\\\\" var=\\\\\\\"p\\\\\\\">\\\\n   \\\\t<a href=\\\\\\\"manager?pageIndex=${p}\\\\\\\">${p}</a>\\\\n   </c:forEach>\\\\n   <c:if test=\\\\\\\"${!page.isIsLastPage()}\\\\\\\">\\\\n   \\\\t<li><a href=\\\\\\\"manager?pageIndex=${page.nextPage}\\\\\\\">下一页</a></li>\\\\n   \\\\t<li><a href=\\\\\\\"manager?pageIndex=${page.lastPage}\\\\\\\">尾页</a></li>\\\\n   </c:if>\\\\n   ```\\\\n# 问题\\\\n\\\\n- 当进行多表查询时，pageTotal总条数被改成了pageSize\\\\n\\\\n\\\\n\\\\n# 原因\\\\n\\\\n### 网上查找的原因\\\\n\\\\n1. ```java\\\\n   PageHelper.startPage(pageIndex, 10);\\\\n   //查询语句\\\\n   pageInfo...\\\\n   ```\\\\n\\\\n   再startPage之后，只能进行一次查询的操作，如果sql里面进行了多次查询，就会导致pageInfo的Total是当前页的总条数。\\\\n\\\\n2. 我在service层中取出数据做了别的操作，导致在controller里面取出数据时就有问题了。\\\\n\\\\n\\\\n\\\\n# 解决\\\\n\\\\n1.  在网上看到的一种思路是通过手动赋值pageTotal\\\\n\\\\n   ```java\\\\n   List<State> stateList1 = managerService.getState();//在分页之前先查询一次，这次查询结果的总条数没有问题\\\\n   PageHelper.startPage(pageIndex, 10);\\\\n   List<State> stateList = managerService.getState();\\\\n   PageInfo<State> page = new PageInfo<>(stateList);\\\\n   page.setTotal(stateList1.size());//给pageInfo设置Total\\\\n   ```\\\\n\\\\n   但是这种方法不能解决我的问题\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n### 我的原因\\\\n\\\\n我通过一个左连接的sql查出来的list，在service层对查出来的数据做了一些操作，返回的是另外一个list\\\\n\\\\nsql：\\\\n\\\\n```sql\\\\nselect w.wno, w.wname, d.height, d.weight, d.heart, d.blood\\\\n        from worker w LEFT JOIN data d\\\\n        on w.wno=d.no\\\\n        order by wno\\\\n```\\\\n\\\\nservice：\\\\n\\\\n```java\\\\npublic List<state>getState(){\\\\n    List<state> stateList = new ArrayList<>();\\\\n    List<state> resultS = managerDao.selectAll();\\\\n    if () {\\\\n        //判断操作\\\\n        stateList.add(...);\\\\n    }\\\\n    return stateList;\\\\n}\\\\n```\\\\n\\\\ncontroller：\\\\n\\\\n```java\\\\nPageHelper.startPage(pageIndex, 10);\\\\nList<state> stateList = managerService.getState();\\\\nPageInfo<state> page = new PageInfo<>(stateList);\\\\n```\\\\n\\\\n最后的解决方法是在service层返回通过sql查出来的List，而不是我在service层new的List\\\\n\\\\npageInfo应该是对sql语句查出来的List进行分页操作，不能对我new出来的List进行分页操作\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleStatus\\\":\\\"1\\\"}\"}', '127.0.0.1', '2019-08-01 16:03:46');
INSERT INTO `t_blog_log` VALUES (19, 'admin', '修改文章是否主页显示状态', '115', 'com.blog.admin.controller.ArticleController.changeMain()', '  id: {\"id\":1}', '127.0.0.1', '2019-08-01 16:03:52');
INSERT INTO `t_blog_log` VALUES (20, 'admin', '修改文章是否主页显示状态', '79', 'com.blog.admin.controller.ArticleController.changeMain()', '  id: {\"id\":2}', '127.0.0.1', '2019-08-01 16:03:53');
INSERT INTO `t_blog_log` VALUES (21, 'admin', '修改文章是否主页显示状态', '84', 'com.blog.admin.controller.ArticleController.changeMain()', '  id: {\"id\":3}', '127.0.0.1', '2019-08-01 16:03:53');
INSERT INTO `t_blog_log` VALUES (22, 'admin', '修改文章是否推荐状态', '77', 'com.blog.admin.controller.ArticleController.changeRec()', '  id: {\"id\":3}', '127.0.0.1', '2019-08-01 16:03:54');
INSERT INTO `t_blog_log` VALUES (23, 'admin', '修改文章是否推荐状态', '411', 'com.blog.admin.controller.ArticleController.changeRec()', '  id: {\"id\":2}', '127.0.0.1', '2019-08-01 16:03:54');
INSERT INTO `t_blog_log` VALUES (24, 'admin', '修改文章是否推荐状态', '105', 'com.blog.admin.controller.ArticleController.changeRec()', '  id: {\"id\":1}', '127.0.0.1', '2019-08-01 16:03:54');
INSERT INTO `t_blog_log` VALUES (25, 'admin', '添加标签', '32', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"框架\\\"}\"}', '221.232.63.96', '2019-08-04 03:00:20');
INSERT INTO `t_blog_log` VALUES (26, 'admin', '发表文章', '48', 'com.blog.admin.controller.ArticleController.addArticle()', '  data: {\"data\":\"{\\\"articleCoverImg\\\":[{\\\"name\\\":\\\"20190804030305.jpg\\\",\\\"url\\\":\\\"http://lsblog.vip/coverImg/20190804030305.jpg\\\",\\\"uid\\\":1564858984801,\\\"status\\\":\\\"success\\\"}],\\\"articleTitle\\\":\\\"MyBatis框架简要介绍\\\",\\\"articleAuthor\\\":\\\"OIA\\\",\\\"isOwn\\\":true,\\\"articleFrom\\\":\\\"\\\",\\\"articleTag\\\":\\\"6,8\\\",\\\"articleClassify\\\":1,\\\"articleDec\\\":\\\"MyBatis框架的简要介绍，包括Mybatis的整体结构、配置文件、xml映射文件、动态sql、事务、缓存以及注解配置\\\",\\\"articleContent\\\":\\\"# MyBatis体系结构\\\\n\\\\n- ### SqlSessionFactory\\\\n\\\\n> 是单个数据库映射关系经过编译后的内存镜像\\\\n\\\\n1. 通过SqlSessionFactoryBuilder对象获取SqlSessionFactory对象的实例。\\\\n2. SqlSessionFactoryBuilder对象通过配置文件或预先定制的Configuration的实例构建。\\\\n3. 每个MyBatis应用程序都以一个SqlSessionFactory对象的实例为核心，其是线程安全的。\\\\n4. SqlSessionFactory一旦被创建，在应用程序的执行期间都存在。所以不需要重复创建多次。\\\\n5. SqlSessionFactory是创建SqlSession的工厂\\\\n6. 常用方法：\\\\n   - ```SqlSession openSession()```：创建SqlSession对象\\\\n\\\\n- ### SqlSession\\\\n\\\\n> 是执行持久化操作的对象，类似JDBC中的Connection\\\\n\\\\n1. 是应用程序和持久化存储层之间执行交互操作的一个单线程对象。\\\\n2. SqlSession对象包含了以数据库为背景的所有执行SQL操作的方法，底层封装了JDBC连接，可以用SqlSession实例来直接执行已映射的SQL语句。\\\\n3. 每个线程都有自己的SqlSession实例。\\\\n4. SqlSession的实例不能被共享，也是线程不安全的。\\\\n\\\\n\\\\n\\\\n# MyBatis的配置文件\\\\n\\\\n**MyBatis的持久化操作离不开SqlSessionFactory对象，该对象的openSession()方法可以创建SqlSession对象**\\\\n\\\\nMyBatis初始化基本过程：\\\\n\\\\n```java\\\\n//读取mybatis-config.xml文件\\\\nInputStream inputStream = Resources.getResourceAsStream(\\\\\\\"mybatis-config.xml\\\\\\\");\\\\n//初始化MyBatis，创建SqlSessionFactory类的实例\\\\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.build(inputStream);\\\\n//创建Session实例\\\\nSqlSession session = sqlSessionFactory.openSession();\\\\n```\\\\n\\\\nMyBatis的初始化就发生在第二句话\\\\n\\\\n\\\\n\\\\n## MyBatis的配置文件结构\\\\n\\\\n- properties 属性\\\\n\\\\n  这些属性都可以通过外部配置动态替换\\\\n\\\\n- settings 设置\\\\n\\\\n  可以改变MyBatis的运行时行为\\\\n\\\\n- tyAliases 类型命名\\\\n\\\\n  是为Java类型设置一个短的名字，只和XML配置有关，仅为了减少类完全限定名的冗余\\\\n\\\\n  形式：\\\\n\\\\n  ```java\\\\n  <typeAliases>\\\\n  \\\\t<typeAlias alias=\\\\\\\"user\\\\\\\" type=\\\\\\\"com.demo.domain.User\\\\\\\"/>\\\\n  </typeAliases>\\\\n  ```\\\\n\\\\n  这样user可以用在任何使用com.demo.domain.User的地方\\\\n\\\\n  ```java\\\\n  <typeAliases>\\\\n  \\\\t<typeAlias name=\\\\\\\"com.demo.domain\\\\\\\"/>\\\\n  </typeAliases>\\\\n  ```\\\\n\\\\n  com.demo.domain包下的每一个JavaBean，没有注解的情况下，则使用Bean的首字母小写的非限定类名作为别名。com.demo.domain.User的别名为user。\\\\n\\\\n  如果有注解，则别名为注解的值\\\\n\\\\n  ```java\\\\n  @Alias(\\\\\\\"user\\\\\\\")\\\\n  public class User{\\\\n      ...\\\\n  }\\\\n  ```\\\\n\\\\n- typeHandlers 类型处理器\\\\n\\\\n- objectFactory 对象工厂\\\\n\\\\n  Mybatis每次创建结果对象的新实例时，会使用一个对象工厂（objectFactory）实例来完成。默认的对象工厂是实例化目标类。\\\\n\\\\n- environments 环境配置\\\\n\\\\n  环境配置实际就是数据源的配置。可以配置多种环境，将sql映射到多种数据库。但要注意每个数据库对应一个SqlSessionFactory，需要连接几个数据库就要几个SqlSessionFactory实例。\\\\n\\\\n- mapper 映射器\\\\n\\\\n  写完sql语句，通过mapper映射器告诉mybatis去哪里找映射文件，进而找到sql语句\\\\n\\\\n\\\\n\\\\n# Mapper XML映射文件\\\\n\\\\n参数符号**#{XXX}**，创建一个预处理语句参数，在JDBC中由一个\\\\\\\"**?**\\\\\\\"来标识。\\\\n\\\\nSQL映射文件常用元素：\\\\n\\\\n- select：映射查询语句\\\\n- insert：映射插入语句\\\\n- update：映射更新语句\\\\n- delete：映射删除语句\\\\n- sql：可以被其他语句块引用的可重用语句块\\\\n- cache：给命名空间的缓存配置\\\\n- cache-ref：其他命名空间缓存配置的引用\\\\n- resultMap：描述如何从数据库结果集中加载对象\\\\n\\\\n关联查询：\\\\n\\\\n```xml\\\\n<!--映射学生对象-->\\\\n<resultMap id=\\\\\\\"student\\\\\\\" type=\\\\\\\"com.demo.domain.Student\\\\\\\">\\\\n    <id property=\\\\\\\"id\\\\\\\" column=\\\\\\\"id\\\\\\\"/>\\\\n    <result property=\\\\\\\"name\\\\\\\" column=\\\\\\\"name\\\\\\\"/>\\\\n    <result property=\\\\\\\"sex\\\\\\\" column=\\\\\\\"sex\\\\\\\"/>\\\\n    <result property=\\\\\\\"age\\\\\\\" column=\\\\\\\"age\\\\\\\"/>\\\\n    <!--关系映射-->\\\\n    <association property=\\\\\\\"clazz\\\\\\\" column=\\\\\\\"clazz_id\\\\\\\" javaType=\\\\\\\"com.demo.domain.Clazz\\\\\\\" select=\\\\\\\"selectClazzById\\\\\\\"/>\\\\n</resultMap>\\\\n<select id=\\\\\\\"selectStudent\\\\\\\" resultType=\\\\\\\"com.demo.domain.Student\\\\\\\">\\\\n    select * from t_student;\\\\n</select>\\\\n<select id=\\\\\\\"selectClazzById\\\\\\\" resultMap=\\\\\\\"student\\\\\\\">\\\\n    select * from t_clazz;\\\\n</select>\\\\n```\\\\n\\\\n如要返回一个list\\\\n\\\\n```xml\\\\n<collection property=\\\\\\\"students\\\\\\\" javaType=\\\\\\\"ArrayList\\\\\\\" column=\\\\\\\"id\\\\\\\" ofType=\\\\\\\"com.demo.domain.Student\\\\\\\" select=\\\\\\\"selectClazzById\\\\\\\"/>\\\\n```\\\\n\\\\nofType：表示集合当中的类型\\\\n\\\\n\\\\n\\\\n# 动态SQL\\\\n\\\\n常用动态SQL元素：\\\\n\\\\n1. if\\\\n2. choose(when、otherwise)\\\\n3. where\\\\n4. set\\\\n5. foreach\\\\n6. bind\\\\n\\\\n### if\\\\n\\\\n> 有条件的包含where子句的一部分\\\\n\\\\n```xml\\\\n<mapper namespace=\\\\\\\"com.demo.domain.UserDao\\\\\\\">\\\\n\\\\t<select id=\\\\\\\"selectUserByIdLike\\\\\\\" resultType=\\\\\\\"com.demo.domain.User\\\\\\\">\\\\n        select * from t_user where clazz = \'1\'\\\\n        <!--可选条件，如果传进来的参数有id，则加上id查询条件-->\\\\n        <if test=\\\\\\\"id != null\\\\\\\">\\\\n            and id = #{id}\\\\n        </if>\\\\n    </select>\\\\n</mapper>\\\\n```\\\\n\\\\n### choose(when、otherwise)\\\\n\\\\n> 当不想用所有的条件语句，只取其中一二的情况，类似Java中的switch语句\\\\n\\\\n```xml\\\\n <select id=\\\\\\\"selectUser\\\\\\\" resultType=\\\\\\\"com.demo.domain.User\\\\\\\">\\\\n        <!--\\\\n\\\\t\\\\t\\\\t如果传入了id就按id查，没有传入id就按loginname和password查，否则查询性别是男的数据\\\\n\\\\t\\\\t\\\\t如果即传入了id又传入了loginname和password，则按id查，因为使用了choose，按照sql中的顺序\\\\n\\\\t\\\\t-->\\\\n        select * from t_user where clazz = \'1\'\\\\n        <choose>\\\\n            <when test=\\\\\\\"id != null\\\\\\\">\\\\n                and id = #{id}\\\\n            </when>\\\\n            <when test=\\\\\\\"loginname != null and password != null\\\\\\\">\\\\n                and loginname = #{loginname} and password = #{password}\\\\n            </when>\\\\n            <otherwise>\\\\n                and sex = \'男\'\\\\n            </otherwise>\\\\n        </choose>\\\\n    </select>\\\\n```\\\\n\\\\n### where\\\\n\\\\n把刚刚的if实例改成如下所示：\\\\n\\\\n```xml\\\\n<mapper namespace=\\\\\\\"com.demo.domain.UserDao\\\\\\\">\\\\n\\\\t<select id=\\\\\\\"selectUserByIdLike\\\\\\\" resultType=\\\\\\\"com.demo.domain.User\\\\\\\">\\\\n        select * from t_user where \\\\n        <if test=\\\\\\\"clazz != null\\\\\\\">\\\\n            clazz = #{clazz}\\\\n        </if>\\\\n        <if test=\\\\\\\"id != null\\\\\\\">\\\\n            and id = #{id}\\\\n        </if>\\\\n    </select>\\\\n</mapper>\\\\n```\\\\n\\\\n如果不传参数：```select * from t_user where```\\\\n\\\\n如果传入id：```select * from t_user where and id = ?```\\\\n\\\\n也就是说不传入clazz参数，sql就会执行失败。\\\\n\\\\n修改如下：\\\\n\\\\n```xml\\\\n<mapper namespace=\\\\\\\"com.demo.domain.UserDao\\\\\\\">\\\\n\\\\t<select id=\\\\\\\"selectUserByIdLike\\\\\\\" resultType=\\\\\\\"com.demo.domain.User\\\\\\\">\\\\n        select * from t_user \\\\n        <where>\\\\n        \\\\t<if test=\\\\\\\"clazz != null\\\\\\\">\\\\n            \\\\tclazz = #{clazz}\\\\n        \\\\t</if>\\\\n        \\\\t<if test=\\\\\\\"id != null\\\\\\\">\\\\n            \\\\tand id = #{id}\\\\n        \\\\t</if>\\\\n        </where>\\\\n    </select>\\\\n</mapper>\\\\n```\\\\n\\\\n这样只有在一个以上的if条件有值得情况下才会插入where子句\\\\n\\\\n### set\\\\n\\\\n> set元素可以用于动态包含需要更新的列，舍去其他的列\\\\n\\\\n```xml\\\\n<update id=\\\\\\\"updateUser\\\\\\\" parameterType=\\\\\\\"com.demo.domain.User\\\\\\\">\\\\n       update t_user\\\\n       <set>\\\\n           <if test=\\\\\\\"name != null\\\\\\\">name=#{name}</if>\\\\n           <if test=\\\\\\\"sex != null\\\\\\\">name=#{sex}</if>\\\\n           <if test=\\\\\\\"age != null\\\\\\\">name=#{age}</if>\\\\n           <if test=\\\\\\\"clazz != null\\\\\\\">name=#{clazz}</if>\\\\n           <if test=\\\\\\\"loginname != null\\\\\\\">name=#{loginname}</if>\\\\n           <if test=\\\\\\\"password != null\\\\\\\">name=#{password}</if>\\\\n       </set>\\\\n       where id = #{id}\\\\n   </update>\\\\n```\\\\n\\\\nset元素会动态前置SET关键字，也会消除无关的逗号\\\\n\\\\n### foreach\\\\n\\\\n> 用于集合的遍历，一般用于构建IN条件语句\\\\n\\\\n```xml\\\\n<select id=\\\\\\\"selectUser\\\\\\\" resultType=\\\\\\\"com.demo.domain.User\\\\\\\">\\\\n       select * from t_user where id in\\\\n       <foreach collection=\\\\\\\"list\\\\\\\" item=\\\\\\\"item\\\\\\\" index=\\\\\\\"index\\\\\\\" open=\\\\\\\"(\\\\\\\" separator=\\\\\\\",\\\\\\\" close=\\\\\\\")\\\\\\\">\\\\n           #{item}\\\\n       </foreach>\\\\n</select>\\\\n```\\\\n\\\\n### bind\\\\n\\\\n> bind元素可以从OGNL表达式构建一个变量并将其绑定到上下文\\\\n\\\\n```xml\\\\n<select id=\\\\\\\"selectUser\\\\\\\" resultType=\\\\\\\"com.demo.domain.User\\\\\\\">\\\\n        <bind name=\\\\\\\"pattern\\\\\\\" value=\\\\\\\"\'%\' + _parameter.getName + \'%\'\\\\\\\"/>\\\\n       select * from t_user\\\\n       where loginname like #{pattern}\\\\n   </select>\\\\n```\\\\n\\\\n对loginname的模糊查询\\\\n\\\\n\\\\n\\\\n# MyBatis事务管理\\\\n\\\\n事务的特性（ACID）\\\\n\\\\n- **原子性**（Atomicity）：\\\\n  - 事务是应用中最小的执行单位，如原子是自然界的最小颗粒，不可再分。事务是应用中不可再分的最小逻辑单元。\\\\n- **一致性**（Consistency）：\\\\n  - 事务执行的结果，必须使数据库从一种一致性状态变到另一种一致性状态，*一致状态*的含义是数据库中的数据应满足完整性约束。\\\\n  - 当数据库只包含事务成功提交的结果时，数据库处于一致性状态。如果系统运行发生中断，某个事务没有完成而被迫中断，而该没有完成的事务对数据库所做的修改已经被写入数据库，此时，数据库就处于一种不正确的状态\\\\n- **隔离性**（Isolation）：\\\\n  - 各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的，即并发执行的事务之间不能互相影响\\\\n- **持续性**（Durability）：\\\\n  - 持续性也被称为持久性（Persistence），指事务一旦提交，对数据库中的数据的改变就是永久性的，即使是数据库系统遇到故障也不会丢失提交事务的操作。即对数据库所做的任何改变都要记录到永久存储器中，通常就是保存到物理数据库。\\\\n\\\\n\\\\n\\\\n## Trasaction接口\\\\n\\\\n- Trasaction接口\\\\n\\\\n  - JdbcTrasaction实现类\\\\n  - ManagedTrasaction实现类\\\\n\\\\n- TrasactionFactory接口\\\\n\\\\n  - JdbcTrasactionFactory实现类\\\\n\\\\n  - ManagedTrasactionFactory实现类\\\\n\\\\n    用来获取事务的实例对象\\\\n\\\\nMyBatis事务管理分为两种形式：\\\\n\\\\n- 使用JDBC的事务管理机制\\\\n- 使用managed的事务管理机制\\\\n\\\\n\\\\n\\\\n## 事务的配置\\\\n\\\\n事务的配置\\\\n\\\\n```xml\\\\n<environment id=\\\\\\\"mysql\\\\\\\">\\\\n            <!--\\\\n            指定事务管理类型\\\\n            type=\\\\\\\"JDBC\\\\\\\"使用JDBC的提交和回滚设置\\\\n            type=\\\\\\\"MANAGED\\\\\\\"指让容器实现对事务的管理\\\\n            -->\\\\n            <transactionManager type=\\\\\\\"JDBC\\\\\\\"/>\\\\n            <dataSource type=\\\\\\\"POOLED\\\\\\\">\\\\n                <property name=\\\\\\\"driver\\\\\\\" value=\\\\\\\"${driver}\\\\\\\"/>\\\\n                <property name=\\\\\\\"url\\\\\\\" value=\\\\\\\"${url}\\\\\\\"/>\\\\n                <property name=\\\\\\\"username\\\\\\\" value=\\\\\\\"${username}\\\\\\\"/>\\\\n                <property name=\\\\\\\"password\\\\\\\" value=\\\\\\\"${password}\\\\\\\"/>\\\\n            </dataSource>\\\\n        </environment>\\\\n```\\\\n\\\\n在SSM中使用事务\\\\n\\\\n```xml\\\\n<!-- 配置事务管理器 -->\\\\n    <bean id=\\\\\\\"transactionManager\\\\\\\" class=\\\\\\\"org.springframework.jdbc.datasource.DataSourceTransactionManager\\\\\\\">  \\\\n        <property name=\\\\\\\"dataSource\\\\\\\" ref=\\\\\\\"dataSource\\\\\\\" />  \\\\n    </bean> \\\\n    <!-- 配置基于注解的声明式事务 @Transactional-->\\\\n    <tx:annotation-driven transaction-manager=\\\\\\\"transactionManager\\\\\\\" />\\\\n```\\\\n\\\\n在需要使用事务的方法上加上@Transactional注解\\\\n\\\\n\\\\n\\\\n# MyBatis缓存机制\\\\n\\\\nMyBatis的查询缓存分类：\\\\n\\\\n- 一级缓存：SqlSession级别的缓存\\\\n- 二级缓存：mapper级别的缓存，多个SqlSession共享的\\\\n\\\\n### 一级缓存\\\\n\\\\n操作数据库时需要构造SqlSession对象，其中有一个HashMap用于存储缓存数据，不同的SqlSession之间的缓存数据区域（HashMap）是互不影响的。\\\\n\\\\n一级缓存的作用域是SqlSession范围，当在同一SqlSession中执行两次，那么第一次执行完会将数据写到缓存（内存），第二次查询时就直接去缓存中取数据，不再走底层数据库查询。如果数据库执行了DML（insert、update和delete），并提交到数据库，Mybatis会清空SqlSession中一级缓存，保证了缓存中存储的数据是最新的信息，避免出现脏读。\\\\n\\\\nMyBatis默认开启一级缓存，不需要配置。\\\\n\\\\n### 二级缓存\\\\n\\\\n使用二级缓存时，多个SqlSession使用同一个mapper的SQL语句去操作数据库，得到的数据会存在二级缓存区域，它是使用HashMap进行数据存储的，相较于一级缓存，二级缓存的范围更大，多个SqlSession可以共享二级缓存中的数据，二级缓存时夸SqlSession的。\\\\n\\\\n其作用域是mapper的同一个namespace。不同的SqlSession两次执行相同的namespace下的SQL语句，并且向SQL中传递的参数也相同，即最终执行相同的SQL语句，当第一个SqlSession调用close()关闭一级缓存时，第一次从数据库中查询的数据会被保存到二级缓存，第二次查询时会从二级缓存中获取数据，不走底层数据库查询。\\\\n\\\\n二级缓存需要配置\\\\n\\\\n```xml\\\\n在mybatis-config.xml文件中\\\\n<settings>\\\\n\\\\t<!--开启二级缓存-->\\\\n    <setting name=\\\\\\\"cacheEnabled\\\\\\\" value=\\\\\\\"true\\\\\\\"/>\\\\n</settings>\\\\n```\\\\n\\\\n```xml\\\\n<!--开启当前mapper的namespace下的二级缓存-->\\\\n<cache eviction=\\\\\\\"LRU\\\\\\\" flushInterval=\\\\\\\"60000\\\\\\\" size=\\\\\\\"512\\\\\\\" readOnly=\\\\\\\"true\\\\\\\"/>\\\\n```\\\\n\\\\n创建了一个LRU缓存，并每隔60s刷新，最大存储512个对象，返回的对象是只读的。\\\\n\\\\n使用二级缓存时，与查询结果映射的Java对象必须实现Serializable接口\\\\n\\\\n\\\\n\\\\n# MyBatis注解配置\\\\n\\\\n常用注解：\\\\n\\\\n- Select\\\\n\\\\n  ```java\\\\n  @Select(\\\\\\\"SELECT * FROM T_USER WHERE id = #{id}\\\\\\\")\\\\n  @Results({\\\\n      @Result(id=true,column=\\\\\\\"id\\\\\\\",property=\\\\\\\"id\\\\\\\"),\\\\n      @Result(column=\\\\\\\"name\\\\\\\",property=\\\\\\\"name\\\\\\\"),\\\\n      @Result(column=\\\\\\\"age\\\\\\\",property=\\\\\\\"age\\\\\\\"),\\\\n      @Result(column=\\\\\\\"sex\\\\\\\",property=\\\\\\\"sex\\\\\\\")\\\\n  })\\\\n  User selectUserById(int id);\\\\n  \\\\n  @Select(\\\\\\\"SELECT * FROM T_USER\\\\\\\")\\\\n  List<User> selectAllUser();\\\\n  ```\\\\n\\\\n- SelectProvider\\\\n\\\\n- Insert\\\\n\\\\n  ```java\\\\n  @Insert(\\\\\\\"INSERT INTO T_USER(name,age,sex) VALUES(#{name},#{age},#{sex})\\\\\\\")\\\\n  //使用数据库自增主键，keyProperty=\\\\\\\"id\\\\\\\"表示将插入数据生成的主键设置到user对象的id当中\\\\n  @Options(useGeneratedKeys=true,keyProperty=\\\\\\\"id\\\\\\\")\\\\n  int saveUser(User user);\\\\n  ```\\\\n\\\\n- InsertProvider\\\\n\\\\n- Update\\\\n\\\\n  ```java\\\\n  @Update(\\\\\\\"UPDATE T_USER SET name = #{name}, age = #{age}, sex = #{sex} where id = #{id}\\\\\\\")\\\\n  void modifyUser(User user);\\\\n  ```\\\\n\\\\n- UpdateProperty\\\\n\\\\n- Delete\\\\n\\\\n  ```java\\\\n  @Delete(\\\\\\\"DELETE FROM T_USER WHERE id = #{id}\\\\\\\")\\\\n  int deleteUserById(@Param(\\\\\\\"id\\\\\\\")int id);\\\\n  ```\\\\n\\\\n- DeleteProperty\\\\n\\\\n- Result：在列和属性之间的单独结果映射\\\\n\\\\n- Results：多个结果映射列表\\\\n\\\\n- Options：提供配置选项的附加值，通常作为附加功能配置\\\\n\\\\n- One：复杂类型的单独属性值映射\\\\n\\\\n- Many：复杂类型的集合属性映射\\\\n\\\\n- Param：当映射器方法需要多个参数时，该注解可以给每个参数取一个名字，否则会以它们的顺序位置和SQL语句中的表达式进行映射。\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleStatus\\\":\\\"1\\\"}\"}', '221.232.63.96', '2019-08-04 03:05:25');
INSERT INTO `t_blog_log` VALUES (27, 'admin', '修改文章是否主页显示状态', '28', 'com.blog.admin.controller.ArticleController.changeMain()', '  id: {\"id\":4}', '221.232.63.96', '2019-08-04 03:05:29');
INSERT INTO `t_blog_log` VALUES (28, 'admin', '修改文章是否推荐状态', '28', 'com.blog.admin.controller.ArticleController.changeRec()', '  id: {\"id\":4}', '221.232.63.96', '2019-08-04 03:05:30');
INSERT INTO `t_blog_log` VALUES (29, 'admin', '修改文章', '31', 'com.blog.admin.controller.ArticleController.editArticle()', '  data: {\"data\":\"{\\\"articleAuthor\\\":\\\"OIA\\\",\\\"articleClassify\\\":1,\\\"articleClassifyID\\\":\\\"1\\\",\\\"articleComment\\\":\\\"\\\",\\\"articleContent\\\":\\\"# SpringMVC的常用注解\\\\n\\\\n##  @Controller注解\\\\n\\\\n> @Controller用于标记一个类，使用它标记的类就是一个SpringMVC Controller对象，即一个控制器类\\\\t\\\\n\\\\n- 使用```<context:component-scan/>```元素，启动包扫描功能，注册带有@Contorller、@Service、@repository、@Component等注解的类成为Spring的Bean。\\\\n\\\\n配置文件如下：\\\\n\\\\n```xml\\\\n<context:component-scan base-package=\\\\\\\"包的路径\\\\\\\"/>\\\\n```\\\\n\\\\n## @RequestMapping注解\\\\n\\\\n### RequestMapping注解简介\\\\n\\\\n> @RequestMapping注解，指示了Spring用哪一个类或方法来处理请求动作，该注解可用于类或方法。\\\\n> @RequestMapping注解可以用来注释一个控制器类，所有方法都将映射为相对于类级别的请求，表示该控制器处理的所有请求都被映射到value属性所指示的路径下。\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@Controller\\\\n@RequestMapping(value=\\\\\\\"/user\\\\\\\")\\\\npublic class UserController {\\\\n    @RequestMapping(value=\\\\\\\"/register\\\\\\\")\\\\n    public String register() {\\\\n        return \\\\\\\"register\\\\\\\";\\\\n    }\\\\n    @RequestMapping(value=\\\\\\\"/login\\\\\\\")\\\\n    public String login() {\\\\n        return \\\\\\\"login\\\\\\\";\\\\n    }\\\\n}\\\\n```\\\\n\\\\n### RequestMapping注解支持的常用属性\\\\n\\\\n#### value属性\\\\n\\\\n> @RequestMapping 是一个用来处理请求地址映射的注解，可以注释一个类或方法。\\\\n\\\\n采用了@RequestMapping注释的方法将成为一个请求处理方法，例如：\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/hello\\\\\\\")\\\\npublic ModelAndView hello() {\\\\n    return ...;\\\\n}\\\\n```\\\\n\\\\n**如果只有唯一的属性时，则可以省略属性名，以下两个注解的含义相同。但如果有超过一个属性，就必须写上value属性名称。**\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/hello\\\\\\\")\\\\n@RequestMapping(\\\\\\\"/hello\\\\\\\")\\\\n```\\\\n\\\\nvalue属性的值可以是一个空字符串，此时该方法被映射到如下请求URL：```http://localhost:8080/context```\\\\n\\\\n\\\\n\\\\n#### method属性\\\\n\\\\n> 该属性用来指示该方法仅处理哪些HTTP请求方式。\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", method=RequestMethod.POST)```，表示该方法只支持POST请求。\\\\n\\\\n  也可以同时支持多个HTTP请求方式\\\\n\\\\n  ```RequestMapping(value=\\\\\\\"/hello\\\\\\\", method={RequestMethod.POST,RequestMethod.GET})```\\\\n\\\\n  如果没有指定method属性值，则请求处理方法可以处理任意的HTTP请求方式。\\\\n\\\\n\\\\n\\\\n#### consumes属性\\\\n\\\\n> 该属性指定请求的提交内容类型（Content-Type）\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", consumes=\\\\\\\"application/json\\\\\\\")```，表示方法仅处理request Content-Type为\\\\\\\"application/json\\\\\\\"类型的请求。\\\\n\\\\n\\\\n\\\\n#### produces属性\\\\n\\\\n> 该属性指定返回的内容类型，返回的内容类型必须是request请求头（Accept）中说包含的类型。\\\\n\\\\n  @RequestMapping(value=\\\\\\\"/hello\\\\\\\", produces=\\\\\\\"application/json\\\\\\\")，表示方法仅处理request请求中Accept头中包含了\\\\\\\"application/json\\\\\\\"的请求，同时指明了返回的内容类型为application/json。\\\\n\\\\n\\\\n\\\\n#### params属性\\\\n\\\\n> 该属性指定request中必须包含某些参数值时，才让该方法处理。\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", params=\\\\\\\"myParam=myValue\\\\\\\")```，表示该方法仅处理其中名为\\\\\\\"myParam\\\\\\\"、值为\\\\\\\"myValue\\\\\\\"的请求。\\\\n\\\\n\\\\n\\\\n#### headers属性\\\\n\\\\n> 该属性指定request中必须包含某些特定的header值时，才能让该方法处理请求。\\\\n\\\\n  ```@RequestMapping(value=\\\\\\\"/hello\\\\\\\", headers=\\\\\\\"Referer=http://www.aaa.com/\\\\\\\")```，表示该方法仅处理header中包含了指定\\\\\\\"Referer\\\\\\\"请求头和对应值为\\\\\\\"http://www.aaa.com\\\\\\\"请求。\\\\n\\\\n\\\\n\\\\n### Model、ModelMap以及ModelAndView\\\\n\\\\n   &emsp;&emsp;SpringMVC在内部使用了一个org.springframework.ui.Model接口存储模型数据，它的功能类似java.util.Map接口，但是比Map易于使用。org.springframewok.ui.ModelMap接口实现了Map接口。\\\\n    &emsp;&emsp;SpringMVC在调用处理方法之前会创建一个隐含的模型对象，作为模型数据的存储容器。\\\\n    &emsp;&emsp;如果处理方法的参数为Model或ModelMap类型，则SpringMVC会见隐含模型的引用传递给这些参数，在处理方法内部，开发者可以通过这个参数对象访问模型中的所有数据，也可以向模型中添加新的数据，添加方法如下：\\\\n      ```addAttribute(String attributeName, Object attributeValue)```\\\\n&emsp;&emsp;控制器处理方法的返回值如果是ModelAndView，则其即包括模型数据信息，也包含视图信息，这样SpringMVC将使用包含的视图对模型数据进行渲染。可以简单的将模型数据看成一个Map<String, Object>对象。\\\\n&emsp;&emsp;ModelAndView对象添加模型数据的方法如下。\\\\n ```addObject(String attributeName, Object attributeValue)```\\\\n&emsp;&emsp;可以通过如下方法设置视图\\\\n ```setVIewName(String viewName)```\\\\n\\\\n\\\\n### 页面转发\\\\n\\\\n> 在JSP中页面转发有两种情况：服务器内部跳转（forward）和客户端重定向（redirect）\\\\n\\\\n#### 转发到JSP页面\\\\n\\\\n**返回值是字符串：**\\\\n\\\\n默认使用服务器内部跳转（forward）。\\\\n\\\\n```return \\\\\\\"main\\\\\\\";```\\\\n\\\\n客户端重定向，在返回的字符串前加上\\\\\\\"redirect:/\\\\\\\"。\\\\n\\\\n```return \\\\\\\"redirect:/main.jsp\\\\\\\";```\\\\n\\\\n**使用ModelAndView：**\\\\n\\\\n默认使用服务器内部跳转（forward）。\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"main\\\\\\\");\\\\n```\\\\n希望重定向。\\\\n\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"redirect:/main.jsp\\\\\\\");\\\\n```\\\\n\\\\n\\\\n由于客户端重定向（redirect）相当于在浏览器重新发送请求，所以不能访问WEB-INF下的资源文件，而且也必须写资源文件后缀名，即.jsp，因为此时springmvc-config.xml文件的视图解析器设置的前缀和后缀都将无效。\\\\n\\\\n\\\\n#### 转发到控制器的请求处理方法\\\\n\\\\n**请求处理方法返回值是字符串：**\\\\n\\\\n```return \\\\\\\"forward:/main\\\\\\\";```\\\\n\\\\n```return \\\\\\\"redirect:/main\\\\\\\";```\\\\n\\\\n**返回值是ModelAndView：**\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"forward:/main\\\\\\\");\\\\n```\\\\n\\\\n```\\\\nmv.setViewName(\\\\\\\"redirect:/main\\\\\\\");\\\\n```\\\\n\\\\n\\\\n\\\\n## @RequestParam注解\\\\n\\\\n> @RequestParam注解用于将指定的请求参数赋值给方法中的形参。\\\\n\\\\n请求处理方法参数的可选类型为Java基本数据类型和String。\\\\t\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/login\\\\\\\")\\\\npublic ModelAndView login(@RequestParam(\\\\\\\"loginname\\\\\\\") String loginname,\\\\n                         @RequestParam(\\\\\\\"password\\\\\\\") String password) {\\\\n    return ...;\\\\n}\\\\n```\\\\n\\\\n需要注意的是，如果请求中不 包含\\\\\\\"loginname\\\\\\\"参数，则将会产生异常！因此，如果不能保证存在loginname参数，建议使用：\\\\n\\\\n```@RequestParam(value=\\\\\\\"loginname\\\\\\\", required=false)```\\\\n\\\\n## @PathVariable注解\\\\n\\\\n> @PathVariable注解可以非常方便地获得请求URL中的动态参数。\\\\n>\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/pathVariableTest/{userId}\\\\\\\")\\\\npublic void pathVariableTest(@PathVariable Integer userId) {\\\\n    ...\\\\n}\\\\n```\\\\n\\\\n假如请求的URL为```\\\\\\\"http://localhost:8080/VariableTest/pathVariableTest/1\\\\\\\"```,则自动将URL中模板变量{userId}绑定到通过@PathVariable注解的同名参数上，即userId变量将被赋值为1.\\\\n\\\\n## @MatrixVariable注解\\\\n\\\\n> @MatrixVariable注解拓展了URL请求地址的功能。使用@MatrixVariable注解时多个变量可以使用\\\\\\\";\\\\\\\"（分号）分隔，该注解允许开发者进行多条件组合查询。\\\\n>\\\\n\\\\n示例代码\\\\n\\\\n```java\\\\n@GetMapping(value=\\\\\\\"/matrixVariableTest/{userId}\\\\\\\")\\\\npublic void matrixVariableTest(@PathVariable Integer userId,\\\\n                              @MatrixVariable(value=\\\\\\\"name\\\\\\\", pathVar=\\\\\\\"userId\\\\\\\") String name,\\\\n                              @MarixVariable(value=\\\\\\\"age\\\\\\\", pathVar=\\\\\\\"userId\\\\\\\") Integer age) {\\\\n    ...\\\\n}\\\\n```\\\\n\\\\n假如请求的URL为```\\\\\\\"http://localhost:8080/VariableTest/matrixVariableTest/1;name=jack;age=23\\\\\\\"```，则自动将URL中模板变量{usrId}绑定到通过@PathVariable注解的同名参数上，即userId变量将被赋值为1；通过@MatrixVariable注解绑定name变量和age变量，即name变量将被赋值为jack，age变量将被赋值为23。\\\\n\\\\n需要注意的是，@MatrixVariable注解功能在SpringMVC中默认不启用的，启用它需要设置```enable-matrix-variables=\\\\\\\"true\\\\\\\"```。\\\\n\\\\n```<mvc:annotation-driven enable-matrix-variables=\\\\\\\"true\\\\\\\"/>```\\\\n\\\\n## @CrossOrigin 注解\\\\n\\\\n> @CrossOrigin注解用于在SpringMVC中处理跨域请求。\\\\n\\\\n| 属性             | 类型            | 是否必要 | 说明                                               |\\\\n| ---------------- | --------------- | -------- | -------------------------------------------------- |\\\\n| allowCredentials | String          | 否       | 包含与请求的域相关的Cookie，使用时必须指定具体的域 |\\\\n| allowedeHeaders  | String[]        | 否       | 请求头中的请求列表                                 |\\\\n| exposedHeaders   | String[]        | 否       | 客户端允许方法的响应头列表                         |\\\\n| maxAge           | long            | 否       | 响应前的缓存最大有效时间，单位是秒                 |\\\\n| methods          | RequestMethod[] | 否       | 请求支持的方法，默认支持RequestMapping中设置的方法 |\\\\n| origins          | String[]        | 否       | 所有支持域的集合，如果没有定义，默认支持所有域     |\\\\n| value            | String[]        | 否       | 同origins属性一样                                  |\\\\n\\\\n\\\\n\\\\n## @RequestHeader 注解\\\\n\\\\n> @RequestHeader注解用于将请求的头信息数据映射到功能处理方法的参数上。\\\\n\\\\n@RequestHeader注解示例代码\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/requestHeaderTest\\\\\\\")\\\\npublic void requestHeaderTest(@RequestHeader(\\\\\\\"User-Agent\\\\\\\") String userAgent,\\\\n                             @RequestHeadr(value=\\\\\\\"Accept\\\\\\\") String[] accepts)\\\\n```\\\\n\\\\n以上配置将自动将请求头“User-Agent”的值赋到userAgent变量上，并将请求头“Accept”的值赋到accepts变量上。\\\\n\\\\n\\\\n\\\\n## @Cookie Value注解\\\\n\\\\n> @CookieValue注解用于将请求的Cookie数据映射到功能处理方法的参数上。\\\\n\\\\n@CookieValue注解示例代码\\\\n\\\\n```java\\\\n@ReqeustMapping(vcalue=\\\\\\\"/cookieValueTest\\\\\\\")\\\\npublic void cookieValueTest(\\\\n    @CookieValue(value=\\\\\\\"JSESSIONID\\\\\\\", defaultValue=\\\\\\\"\\\\\\\")String sessionId)\\\\n```\\\\n\\\\n​\\\\t以上配置会自动将Cookie中JSESSIONID的值设置到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。\\\\n\\\\n\\\\n\\\\n## @RequestAttribute注解\\\\n\\\\n> @RequestAttribbute注解用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于request作用域中的属性，将该属性转换到目标方法的参数。\\\\n\\\\n​\\\\t@RequestAttribute注解示例代码\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/attributeTest\\\\\\\")\\\\npublic void attributeTest(\\\\n\\\\t@RequestAttribute(value=\\\\\\\"username\\\\\\\") String username)\\\\n```\\\\n\\\\n以上代码会指定将request作用域中名为username的属性的值设置到username参数上。\\\\n\\\\n\\\\n\\\\n## @SessionAttribute注解\\\\n\\\\n> @SessionAttribute注解用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于session作用域中的属性，将该属性转换到目标方法的参数。\\\\n\\\\n​\\\\t@SessionAttribute注解示例代码\\\\n\\\\n```java\\\\n@RequestMapping(value=\\\\\\\"/attributeTest\\\\\\\")\\\\npublic void attributeTest(\\\\n\\\\t\\\\t@SessionAttribute(value=\\\\\\\"username\\\\\\\") String username)\\\\n```\\\\n\\\\n​\\\\t以上代码会自动将session作用域中名为username的属性的值设置到username参数上。\\\\n\\\\n\\\\n\\\\n## @SessionAttributes注解\\\\n\\\\n> @SessionAttributes注解允许我们有选择的指定Model中的哪些属性转存到HttpSession对象当中。\\\\n\\\\n@SessionAttributes注解只能声明在类上，而不能声明在方法上。\\\\n\\\\n\\\\n\\\\n## @ModelAttribute注解\\\\n\\\\n> @ModelAttribute注解用于将请求参数绑定到对象。@ModelAttribute注解只支持一个属性value，类型为String，表示绑定的属性名称。\\\\n\\\\n被@ModelAttribute注解的方法会在Controller每个方法执行前被执行，因此在一个Controller被映射到多个URL时，要谨慎使用。\\\\n\\\\n@ModelAttribute注解示例代码\\\\n\\\\n```java\\\\n@Controller\\\\npublic class ModelAttribute1Controller {\\\\n        @ModelAttribute(\\\\\\\"loginname\\\\\\\")\\\\n        public String userModel1(@RequestParam(\\\\\\\"loginname\\\\\\\") String loginname) {\\\\n            return loginname;\\\\n        }\\\\n        @RequestMapping(value=\\\\\\\"/login1\\\\\\\")\\\\n        public String login1() {\\\\n            return \\\\\\\"result1\\\\\\\";\\\\n        }\\\\n}\\\\n```\\\\n\\\\n​\\\\t\\\\t在ModelAttribute1Controller类中除了@ReqesutMapping映射的login1方法之外，还提供了一个userModel1方法，该方法上有一个@ModelAttribute注解。此处@ModelAttribute注解默认的value值为“loginname”，用来指定model属性的名称，而model属性的值就是userModel1方法的返回值。被@ModelAttribute注解的userModel1方法会先于login1调用，它把请求参数loginname的值赋给loginname变量，并设置了一个属性loginname到Model中，而属性的值就时loginname变量的值。\\\\n\\\\n\\\\n\\\\n## @ReqeustBody注解\\\\n\\\\n> @RequestBody注解常用来处理Content-Type：不是application/x-www-form-urlencoded编码的内容，例如application/json、application/xml等。@RequestBody注解通过使用HandlerAdapter配置的HttpMessageConverters来解析JSON或XML数据，然后绑定到相应的Bean上。\\\\n\\\\n### HttpMessageConverter<T>接口\\\\n\\\\n> \\\\t负责将请求信息转换为一个对象（类型为T），并将对象（类型为T）绑定到请求方法的参数上或输出为响应信息。DIspatcherServlet默认已经装配了RequestMappingHandlerAdapter作为HandlerAdapter组件的实现类，即HttpMessageConverter由RequestMappingHandlerAdapter使用，将请求信息转换为对象，或将对象转换为响应信息。\\\\n\\\\nHttpMessageConverter<T>接口中定义了以下几个方法：\\\\n\\\\n- boolean **canRead**(Class<?> clazz, MediaType mediaType)\\\\n\\\\n- boolean **canWrite**(Class<?> clazz, MediaType mediaType)\\\\n\\\\n- List<MediaType> **getSupportedMediaTypes**()\\\\n\\\\n- T **read**(Class<? extends T> clazz, HttpInputMessage inputMessage)\\\\n\\\\n- void write(T t, MediaType contentType, HttpOutputMessage outputMessage)\\\\n\\\\n  String为HttpMessageConverter<T>提供了多个实现类，这些实现类组成了一个功能强大、用途广泛的信息转换家族。列举几个主要的：\\\\n\\\\n  - StringHttpMessageConverter。将请求信息转换为字符串。泛型T为String类型，可以读取所有媒体类(*/*)的请求信息，可通过设置supportMediaTypes属性指定媒体类型。响应信息的媒体类型为text/plain（即Content-Type的值）。 \\\\n  - **MappingJackson2HttpMessageConverter。利用Jackson开源类包读写JSON数据。泛型T为Object类型，可以读取application/json类型的数据，响应信息的类型为application/json。**\\\\n\\\\n\\\\n\\\\n### 转换JSON数据\\\\n\\\\n> \\\\t@RequestBody注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到Controller中方法的参数上。\\\\n\\\\n当前台页面使用GET或POST方式提交数据时，数据编码格式由请求头的ContentType指定。可以分为以下几种情况：\\\\n\\\\n- **application/x-www-form-urlencoded**。这种情况的数据@RequestParam、@ModelAttribute也可以处理，@RequestBody也可以处理。\\\\n- **multipart/form-data**。@RequestBody不能处理这种格式的数据。\\\\n- **application/json**、**application/xml**等格式的数据，必须使用@RequestBody来处理。\\\\n\\\\n\\\\n\\\\n### 自定义HttpMessageConverter接收JSON格式的数据\\\\n\\\\n配置文件：\\\\n\\\\n```xml\\\\n<!-- 配置fastjson中实现HttpMessageConverter接口的转换器 -->\\\\n<!-- FastJsonHttpMessageConverter是fastjson中实现HttpMessageConverter接口的类 -->\\\\n<bean id=\\\\\\\"fastJsonHttpMessageConverter\\\\\\\" class=\\\\\\\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\\\\\\\">\\\\n\\\\t<!-- 加入支持的媒体类型：返回contentType -->\\\\n    <property name=\\\\\\\"supportedMediaTypes\\\\\\\">\\\\n    \\\\t<list>\\\\n        \\\\t<!-- 这里顺序不能反，一定先写text/html，不然IE下会出现下载提示 -->\\\\n            <value>text/html;charset=UTF-8</value>\\\\n            <value>application/json;charset=UTF-8</value>\\\\n        </list>\\\\n    </property>\\\\n</bean>\\\\n```\\\\n\\\\n```<mvc:message-converters register=default=\\\\\\\"false\\\\\\\">```设置不使用默认的消息转换器。\\\\n\\\\n\\\\n\\\\n## @ResponseBody注解\\\\n\\\\n> @ResponseBody注解用于将Controller的请求处理方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。当返回的数据不是HTML标签的页面时，而是其他某种格式的数据时（如JSON、XML等）使用它。\\\\n\\\\n不走视图解析器。\\\\n\\\\n\\\\n\\\\n## @RestController注解\\\\n\\\\n> @RestController注解本身使用@Controller和@ResponseBody注解。使用了 @RestController注解的类会被看作一个Controller，而该类中所有使用@RequestMapping注解的方法都默认使用了@ResponseBody注解。\\\\n\\\\n\\\\n\\\\n## SpringMVC的异常处理\\\\n\\\\n1. 使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver。\\\\n2. 使用@ExceptionHandler注解实现局部异常处理或使用@ControllerAdvice注解实现统一异常处理\\\\n\\\\n### @ResponseStatus注解\\\\n\\\\n> @ResponseStatus注解，通常修饰的是一个异常类\\\\n\\\\n先声明一个自定义异常类，在自定义异常类上面加上@ResponseStatus注解，表示在系统运行时期，当抛出自定义异常的时候，使用@ResponseStatus注解中声明的value属性和reason属性将异常信息返回给客户端。\\\\n\\\\n示例代码\\\\n\\\\n```java\\\\n@ResponseStatus(reason=\\\\\\\"查询数据失败\\\\\\\")\\\\npublic class BookException extends RunTimeException{\\\\n}\\\\n\\\\n@Controller\\\\npublic class BookController{\\\\n    \\\\n    @GetMapping(\\\\\\\"/find\\\\\\\")\\\\n\\\\tpublic String find() throws Exception{\\\\n        try {\\\\n            int i = 5/0;\\\\n            return \\\\\\\"success\\\\\\\";\\\\n        } catch(Exception e) {\\\\n            throw new BookException();\\\\n        }\\\\n    }\\\\n\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n### @ExceptionHandler注解\\\\n\\\\n> @Exceptionhandler注解的作用对象为方法，并且运行时有效，value()可以指定异常类\\\\n\\\\n@ExceptionHandler注解的方法可以支持的参数除了HttpServletRequest、HttpServletRespnse等对象外，还支持一个异常参数，包括一般的异常或自定义异常。如果注解没有指定异常类，会默认进行映射。\\\\n\\\\n\\\\n\\\\n@ControllerAdvice注解\\\\n\\\\n> ControllerAdvice是一个控制器增强功能注解\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleCoverImg\\\":[{\\\"name\\\":\\\"20190801154707.jpg\\\",\\\"url\\\":\\\"http://lsblog.vip/coverImg/20190801154707.jpg\\\",\\\"uid\\\":1564859141250,\\\"status\\\":\\\"success\\\"}],\\\"articleCreationTime\\\":\\\"\\\",\\\"articleDec\\\":\\\"SpringMVC相关的常用注解\\\",\\\"articleFrom\\\":\\\"\\\",\\\"articleLastUpdateTime\\\":\\\"\\\",\\\"articleStatus\\\":\\\"1\\\",\\\"articleTag\\\":\\\"1,4,8\\\",\\\"articleTagID\\\":\\\"1,4\\\",\\\"articleTitle\\\":\\\"SpringMVC的常用注解\\\",\\\"articleView\\\":\\\"\\\",\\\"id\\\":1,\\\"isDelete\\\":\\\"\\\",\\\"isMain\\\":\\\"\\\",\\\"isOwn\\\":true,\\\"isRec\\\":\\\"\\\"}\"}', '221.232.63.96', '2019-08-04 03:05:52');
INSERT INTO `t_blog_log` VALUES (30, 'admin', '修改文章', '13', 'com.blog.admin.controller.ArticleController.editArticle()', '  data: {\"data\":\"{\\\"articleAuthor\\\":\\\"OIA\\\",\\\"articleClassify\\\":1,\\\"articleClassifyID\\\":\\\"1\\\",\\\"articleComment\\\":\\\"\\\",\\\"articleContent\\\":\\\"## 文件上传\\\\n\\\\n**必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这种情况下，浏览器才会把用户选择的文件二进制数据发送给服务器。**\\\\n\\\\n*一般使用Commons FileUpload组件*\\\\n\\\\n\\\\n\\\\nSpringMVC实现了一个MultipartResolver类：CommonsMultipartResolver，因此SpringMVC上传文件需要依赖Apache Commons FileUpload组件（commons-fileupload和commons-io）\\\\n\\\\n示例代码：\\\\n\\\\n前端：\\\\n\\\\n```html\\\\n<form action=\\\\\\\"upload\\\\\\\" enctype=\\\\\\\"multipart/form-data\\\\\\\" method=\\\\\\\"post\\\\\\\">\\\\n    <input type=\\\\\\\"file\\\\\\\" name=\\\\\\\"file\\\\\\\"/>\\\\n</form>\\\\n```\\\\n\\\\n后端：\\\\n\\\\n```java\\\\n@Controller\\\\npublic class FileUploadController{\\\\n    //上传文件会自动绑定到MultipartFile\\\\n    @PostMapping(\\\\\\\"/upload\\\\\\\")\\\\n    public String upload(HttpServletRequest request, \\\\n                        @RequestParam(\\\\\\\"file\\\\\\\") MultipartFile file) throw Exception {\\\\n        \\\\n        //如果文件不为空，写入上传路径\\\\n        if(!file.isEmpty()) {\\\\n            //上传路径\\\\n            String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n        \\\\t//上传文件名\\\\n            String filename = file.getOriginalFilename();\\\\n            File filepath = new File(path, filename);\\\\n        \\\\t//判断路径是否存在，不存在就创建一个\\\\n            if(!filepath.getParentFile().exists()) {\\\\n                filepath.getParentFile().mkdirs();\\\\n            }\\\\n            //将上传的文件保存到一个目标文件当中\\\\n            file.transferTo(new File(path+File.separator+filename));\\\\n        \\\\tSystem.out.println(\\\\\\\"上传文件的路径：\\\\\\\" + (path+File.separator+filename));\\\\n            return \\\\\\\"success\\\\\\\";\\\\n        } else {\\\\n            return \\\\\\\"error\\\\\\\";\\\\n        }\\\\n    }\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n### MultipartFile对象的常用方法\\\\n\\\\n- `byte[] getBytes()` ：获取文件数据\\\\n- `String getContentType()`： 获取文件MIME类型，如image/jpeg等\\\\n- `InputStream getInputStream()`： 获取文件流\\\\n- `String getName()`：获取表单中文件组件的名称\\\\n- `String getOriginalFilename()`： 获取上传文件的原名\\\\n- `long getSize()`： 获取文件的字节大小，单位为byte\\\\n- `boolean isEmpty()`： 是否有上传的文件\\\\n- `void transferTo(FIle dest)`：将上传的文件保存到一个目标文件中\\\\n\\\\nSpringMVC中默认没有装配MultipartResolver，如果要使用SpringMVC的文件上传功能，需要在上下文中配置。\\\\n\\\\n```xml\\\\n<!-- 文件上传配置 -->\\\\n<bean id=\\\\\\\"multipartResolver\\\\\\\" class=\\\\\\\"org.springframeword.web.multipart.commons.CommonsMultipartResolver\\\\\\\">\\\\n    <!-- 上传文件大小上限，单位是字节（10MB） -->\\\\n\\\\t<property name=\\\\\\\"maxUploadSize\\\\\\\">\\\\n        <value>10485760</value>\\\\n    </property>\\\\n    <!-- 请求的编码格式，必须和jsp的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\\\\n\\\\t<property name=\\\\\\\"defaultEncoding\\\\\\\">\\\\n    \\\\t<value>UTF-8</value>\\\\n    </property>\\\\n</bean>  \\\\n```\\\\n\\\\n\\\\n\\\\n## 文件下载\\\\n\\\\nSpringMVC提供了一个ResponseEntity类型，可以定义返回的BodyBuilder、HttpHeaders和HJttpStatus\\\\n\\\\n示例代码：\\\\n\\\\n```java\\\\n@GetMapping(\\\\\\\"/download\\\\\\\")\\\\npublic ResponseEntity<byte[]> download(HttpServletRequest request,\\\\n                                      @RequestParam(\\\\\\\"filename\\\\\\\") String filename,\\\\n                                      @RequestHeader(\\\\\\\"User-Agent\\\\\\\") String userAgent)\\\\nthrow Exception{\\\\n    //下载路径\\\\n    String path = request.getServletContext().getRealPath(\\\\\\\"/images\\\\\\\");\\\\n    //构建file\\\\n    File file = new File(path + File.separator + filename);\\\\n    //ok=200状态码\\\\n    BodyBuilder builder = ResponseEntity.ok();\\\\n    //内容长度\\\\n    builder.contentLength(file.length());\\\\n    //applicaiton/octet-stream:二进制流数据\\\\n    builder.contentType(MediaType.APPLICATION_OCTET_STREAM);\\\\n    //使用URLDecoder.decode对文件名进行解码\\\\n    filename = URLEncoder.encode(filename, \\\\\\\"UTF-8\\\\\\\");\\\\n    //设置实际的响应文件名，告诉浏览器文件要以附件形式打开\\\\n    //不同的浏览器，处理方式不同，要根据浏览器版本进行区别判断\\\\n    if(userAgent.indexOf(\\\\\\\"MSIE\\\\\\\") > 0) {\\\\n        //如果是IE，只需要用UTF-8字符集进行URL编码即可\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename=\\\\\\\"+filename);\\\\n    } else {\\\\n        //而Firefox、Chrome等浏览器，则需要说明编码的字符集\\\\n        //注意filename后面有个*号，在UTF-8后面有两个单引号\\\\n        builder.header(\\\\\\\"Content-Disposition\\\\\\\", \\\\\\\"attachment; filename*=UTF-8\'\'\\\\\\\"+filename);\\\\n    }\\\\n    return builer.body(FileUtils.readFileToByteArray(file));\\\\n}\\\\n```\\\\n\\\\ndownload处理方法接收到页面传递的文件名filename后，使用Apache Commons FileUpload组件的FileUtils读取项目的images文件夹下的该文件，并将其构建成ResponseEntity对象返回给客户端下载。\\\\n\\\\n\\\\n\\\\n## 拦截器\\\\n\\\\n> Interceptor拦截器，它的主要功能是拦截用户的请求并进行相应的处理。比如用户权限验证，判断用户是否已经登录等。\\\\n\\\\n### HandlerInterceptor接口\\\\n\\\\nSpringMVC中的Interceptor拦截器拦截请求是通过实现HandlerInterceptor接口来完成的，在SpringMVC中定义一个Interceptor拦截器，通常在要定义的Interceptor拦截器类中实现Spring的HandlerInteceptor接口，或者继承抽象类HandlerInterceptorAdapter。\\\\n\\\\nHandlerInterceptor接口中定义了三个方法：\\\\n\\\\n- **boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)**：在请求处理前调用，当返回的是false则请求结束，当返回的是true，继续执行。\\\\n- **void postHandle(HttpServletReqeust request, HttpServletResponse response, Object handler, ModelAndView mv)**：当前请求被处理之后，也就是Controller方法被调用之后执行，但是会在DispatcherServlet进行视图返回渲染之前被调用，所以可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。\\\\n- **void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object hadnler, Exception exception)**：将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图后执行。主要进行资源的清理。\\\\n\\\\n示例代码：\\\\n\\\\n设计一个拦截器验证用户是否登录，没有登录，不可以访问除登录外页面和登录请求外的Controller\\\\n\\\\n```java\\\\n/**\\\\n * 拦截器必须实现HandlerInterceptor接口\\\\n */\\\\npublic class AuthorizationInterceptor implements HandlerInterceptor {\\\\n\\\\n    //不拦截\\\\\\\"/loginForm\\\\\\\" 和\\\\\\\"/login\\\\\\\"请求\\\\n    private static final String[] IGNORE_URI = {\\\\\\\"/loginForm\\\\\\\", \\\\\\\"/login\\\\\\\"};\\\\n\\\\n    /**\\\\n     * preHandle方法是进行处理器拦截用的，该方法将在Controller处理之前调用\\\\n     * 该方法的返回值为true时拦截器才会继续往下执行，该方法的返回值为false时，整个请求就结束了\\\\n     */\\\\n    @Override\\\\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor preHandle...\\\\\\\");\\\\n        //flag判断用户是否登录\\\\n        boolean flag  = false;\\\\n        //获取请求路径\\\\n        String servletPath = request.getServletPath();\\\\n        //判断请求是否需要拦截\\\\n        for (String s : IGNORE_URI) {\\\\n            if (servletPath.contains(s)) {\\\\n                flag = true;\\\\n                break;\\\\n            }\\\\n        }\\\\n        //拦截请求\\\\n        if (!flag) {\\\\n            //1、获取session中的用户\\\\n            User user = request.getSession().getAttribute(\\\\\\\"user\\\\\\\");\\\\n            //2、判断用户是否已经登录\\\\n            if (user == null) {\\\\n                System.out.println(\\\\\\\"用户没有登录\\\\\\\");\\\\n                request.setAttribute(\\\\\\\"message\\\\\\\", \\\\\\\"请先登录\\\\\\\");\\\\n                request.getRequestDispatcher(\\\\\\\"loginForm\\\\\\\").forward(request, response);\\\\n            } else {\\\\n                System.out.println(\\\\\\\"用户登录了，可以访问\\\\\\\");\\\\n                flag = true;\\\\n            }\\\\n        }\\\\n        return false;\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在Controller的调用之后执行，方法中可以对ModelAndView进行操作\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor postHandle...\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * 该方法将在整个请求完成之后执行，主要作用是清理资源\\\\n     * 该方法也只能在当前Interceptor的preHandle方法返回值为true时才执行\\\\n     */\\\\n    @Override\\\\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\\\\n        System.out.println(\\\\\\\"AuthorizationInterceptor afterCompletion...\\\\\\\");\\\\n    }\\\\n}\\\\n\\\\n```\\\\n\\\\n在springmvc-config.xml文件中配置拦截器\\\\n\\\\n```xml\\\\n<!-- spring mvc拦截器配置 -->\\\\n<mvc:interceptors>\\\\n\\\\t<mvc:interceptor>\\\\n\\\\t\\\\t<!-- 拦截所有请求 -->\\\\n        <mvc:mapping path=\\\\\\\"/\\\\\\\"/>\\\\n        <!-- 使用bean顶一个Interceptor -->\\\\n        <bean class=\\\\\\\"org.fkit.interceptor.AuthorizationInterceptor\\\\\\\"/>\\\\n    </mvc:interceptor>\\\\n</mvc:interceptors>\\\\n```\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleCoverImg\\\":[{\\\"name\\\":\\\"20190801160003.jpg\\\",\\\"url\\\":\\\"http://lsblog.vip/coverImg/20190801160003.jpg\\\",\\\"uid\\\":1564859159077,\\\"status\\\":\\\"success\\\"}],\\\"articleCreationTime\\\":\\\"\\\",\\\"articleDec\\\":\\\"springmvc中文件的长传和下载，以及springmvc中如何应用拦截器\\\",\\\"articleFrom\\\":\\\"\\\",\\\"articleLastUpdateTime\\\":\\\"\\\",\\\"articleStatus\\\":\\\"1\\\",\\\"articleTag\\\":\\\"1,8\\\",\\\"articleTagID\\\":\\\"1\\\",\\\"articleTitle\\\":\\\"SpringMVC的文件上传下载和拦截器机制\\\",\\\"articleView\\\":\\\"\\\",\\\"id\\\":2,\\\"isDelete\\\":\\\"\\\",\\\"isMain\\\":\\\"\\\",\\\"isOwn\\\":true,\\\"isRec\\\":\\\"\\\"}\"}', '221.232.63.96', '2019-08-04 03:06:07');
INSERT INTO `t_blog_log` VALUES (31, 'admin', '添加标签', '37', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"系统设计\\\"}\"}', '221.232.63.96', '2019-08-04 20:32:04');
INSERT INTO `t_blog_log` VALUES (32, 'admin', '发表文章', '32', 'com.blog.admin.controller.ArticleController.addArticle()', '  data: {\"data\":\"{\\\"articleCoverImg\\\":[{\\\"name\\\":\\\"20190804203710.jpg\\\",\\\"url\\\":\\\"http://lsblog.vip/coverImg/20190804203710.jpg\\\",\\\"uid\\\":1564922230671,\\\"status\\\":\\\"success\\\"}],\\\"articleTitle\\\":\\\"本博客的楼中楼评论设计\\\",\\\"articleAuthor\\\":\\\"OIA\\\",\\\"isOwn\\\":true,\\\"articleFrom\\\":\\\"\\\",\\\"articleTag\\\":\\\"9\\\",\\\"articleClassify\\\":1,\\\"articleDec\\\":\\\"楼中楼评论系统的设计与实现\\\",\\\"articleContent\\\":\\\"### 效果图\\\\n\\\\n![](http://lsblog.vip/articleImg/20190804202728.jpg)\\\\n\\\\n### 数据库设计\\\\n\\\\n在此只给出关键字段\\\\n\\\\n| 字段    | 注释           |\\\\n| ------- | -------------- |\\\\n| id      | 评论id         |\\\\n| content | 评论内容       |\\\\n| time    | 时间           |\\\\n| pid     | 此评论的父级id |\\\\n\\\\n\\\\n\\\\n### 评论DTO\\\\n\\\\n```java\\\\npublic class CommentDTO {\\\\n\\\\n    private Comment comment;\\\\n\\\\n    private List<CommentDTO> nodes;\\\\n\\\\t\\\\n    //getter/setter省略\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n生成的数据格式应该如下：\\\\n\\\\n```json\\\\n{\\\\n    \\\\\\\"data\\\\\\\": [\\\\n        {\\\\n            \\\\\\\"comment\\\\\\\": {\\\\n                \\\\\\\"commentContent\\\\\\\": \\\\\\\"7\\\\\\\",\\\\n                \\\\\\\"commentPid\\\\\\\": \\\\\\\"\\\\\\\",\\\\n                \\\\\\\"commentTime\\\\\\\": \\\\\\\"2019-08-04 16:23:40\\\\\\\",\\\\n                \\\\\\\"id\\\\\\\": \\\\\\\"7\\\\\\\"\\\\n            },\\\\n            \\\\\\\"nodes\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"comment\\\\\\\": {\\\\n                \\\\\\\"commentContent\\\\\\\": \\\\\\\"3\\\\\\\",\\\\n                \\\\\\\"commentPid\\\\\\\": \\\\\\\"\\\\\\\",\\\\n                \\\\\\\"commentTime\\\\\\\": \\\\\\\"2019-08-04 16:11:16\\\\\\\",\\\\n                \\\\\\\"id\\\\\\\": \\\\\\\"3\\\\\\\"\\\\n            },\\\\n            \\\\\\\"nodes\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"comment\\\\\\\": {\\\\n                        \\\\\\\"commentContent\\\\\\\": \\\\\\\"5\\\\\\\",\\\\n                        \\\\\\\"commentPid\\\\\\\": \\\\\\\"3\\\\\\\",\\\\n                        \\\\\\\"commentTime\\\\\\\": \\\\\\\"2019-08-04 16:21:49\\\\\\\",\\\\n                        \\\\\\\"id\\\\\\\": \\\\\\\"5\\\\\\\"\\\\n                    },\\\\n                    \\\\\\\"nodes\\\\\\\": []\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"comment\\\\\\\": {\\\\n                \\\\\\\"commentContent\\\\\\\": \\\\\\\"1\\\\\\\",\\\\n                \\\\\\\"commentPid\\\\\\\": \\\\\\\"\\\\\\\",\\\\n                \\\\\\\"commentTime\\\\\\\": \\\\\\\"2019-08-01 14:54:46\\\\\\\",\\\\n                \\\\\\\"id\\\\\\\": \\\\\\\"1\\\\\\\"\\\\n            },\\\\n            \\\\\\\"nodes\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"comment\\\\\\\": {\\\\n                        \\\\\\\"commentContent\\\\\\\": \\\\\\\"6\\\\\\\",\\\\n                        \\\\\\\"commentPid\\\\\\\": \\\\\\\"1\\\\\\\",\\\\n                        \\\\\\\"commentTime\\\\\\\": \\\\\\\"2019-08-04 16:23:28\\\\\\\",\\\\n                        \\\\\\\"id\\\\\\\": \\\\\\\"6\\\\\\\"\\\\n                    },\\\\n                    \\\\\\\"nodes\\\\\\\": []\\\\n                },\\\\n                {\\\\n                    \\\\\\\"comment\\\\\\\": {\\\\n                        \\\\\\\"commentContent\\\\\\\": \\\\\\\"2\\\\\\\",\\\\n                        \\\\\\\"commentPid\\\\\\\": \\\\\\\"1\\\\\\\",\\\\n                        \\\\\\\"commentTime\\\\\\\": \\\\\\\"2019-08-01 14:56:14\\\\\\\",\\\\n                        \\\\\\\"id\\\\\\\": \\\\\\\"2\\\\\\\"\\\\n                    },\\\\n                    \\\\\\\"nodes\\\\\\\": [\\\\n                        {\\\\n                            \\\\\\\"comment\\\\\\\": {\\\\n                                \\\\\\\"commentContent\\\\\\\": \\\\\\\"4\\\\\\\",\\\\n                                \\\\\\\"commentPid\\\\\\\": \\\\\\\"2\\\\\\\",\\\\n                                \\\\\\\"commentTime\\\\\\\": \\\\\\\"2019-08-04 16:21:31\\\\\\\",\\\\n                                \\\\\\\"id\\\\\\\": \\\\\\\"4\\\\\\\"\\\\n                            },\\\\n                            \\\\\\\"nodes\\\\\\\": []\\\\n                        }\\\\n                    ]\\\\n                }\\\\n            ]\\\\n        }\\\\n    ]\\\\n}\\\\n```\\\\n\\\\n### 后端代码\\\\n\\\\n通过递归构建以上的json格式\\\\n\\\\n```java\\\\n@Override\\\\n    public List<CommentDTO> getMsgboardComment() {\\\\n        List<Comment> rs = commentDao.selectList(query);\\\\n        return buildComment(rs);\\\\n    }\\\\n\\\\n\\\\n    /**\\\\n     * 构建评论列表\\\\n     * @param list\\\\n     * @return\\\\n     */\\\\n    private List<CommentDTO> buildComment(List<Comment> list) {\\\\n        //将结果集转换成CommentDTO类型\\\\n        List<CommentDTO> rsDto = new ArrayList<>();\\\\n        for (Comment r : list) {\\\\n            CommentDTO commentDTO = new CommentDTO();\\\\n            commentDTO.setComment(r);\\\\n            rsDto.add(commentDTO);\\\\n        }\\\\n\\\\n        //获取所有根节点\\\\n        List<CommentDTO> rootNodes = new ArrayList<>();\\\\n        for (CommentDTO commentDTO : rsDto) {\\\\n            if (commentDTO.getComment().getCommentPid() == null || \\\\\\\"\\\\\\\".equals(commentDTO.getComment().getCommentPid())) {\\\\n                rootNodes.add(commentDTO);\\\\n            }\\\\n        }\\\\n\\\\n        //获取根节点下的子节点\\\\n        List<CommentDTO> res = new ArrayList<>();\\\\n        for (CommentDTO commentDTO : rootNodes) {\\\\n            CommentDTO commentDTO1 = buildTree(commentDTO.getComment(), rsDto);\\\\n            res.add(commentDTO1);\\\\n        }\\\\n        return res;\\\\n    }\\\\n\\\\n    /**\\\\n     * 递归构建评论列表\\\\n     *\\\\n     * @param list\\\\n     * @return\\\\n     */\\\\n    private CommentDTO buildTree(Comment comment, List<CommentDTO> list) {\\\\n        //获取当前节点对象\\\\n        CommentDTO node = new CommentDTO();\\\\n        for (CommentDTO commentDTO : list) {\\\\n            if (commentDTO.getComment().getId().equals(comment.getId())) {\\\\n                node = commentDTO;\\\\n            }\\\\n        }\\\\n        //查询当前节点下的所有子节点\\\\n        List<CommentDTO> childNodes = new ArrayList<>();//所有子节点\\\\n        for (CommentDTO commentDTO : list) {\\\\n            if (commentDTO.getComment().getCommentPid().equals(comment.getId())) {\\\\n                childNodes.add(commentDTO);\\\\n            }\\\\n        }\\\\n\\\\n        for (CommentDTO child : childNodes) {\\\\n            CommentDTO commentDTO = buildTree(child.getComment(), list);//递归\\\\n            node.getNodes().add(commentDTO);//存入当前节点的子节点中\\\\n        }\\\\n\\\\n        return node;\\\\n    }\\\\n```\\\\n\\\\n至此后端构建数据完成，现在要到前端去解析这些数据并渲染出来。\\\\n\\\\n### 前端代码\\\\n\\\\n```javascript\\\\n//根节点\\\\nvar rootNode;\\\\n//子节点\\\\nvar childNodes = [];\\\\n//所有评论\\\\nvar comments = [];\\\\n\\\\nfunction initComments() {\\\\n    getAJax(site.msgboard, function (res) {\\\\n        //处理评论信息\\\\n        for (let i = 0; i < res.data.length; i++) {\\\\n            rootNode = res.data[i].comment;\\\\n            if (res.data[i].nodes.length > 0) {//说明有子节点\\\\n                tree(res.data[i]);\\\\n            }\\\\n            let comment = {\\\\n                node: rootNode,\\\\n                childNodes: childNodes\\\\n            };\\\\n            comments.push(comment);\\\\n            //初始化，构建下一条评论\\\\n            rootNode = 0;\\\\n            childNodes = [];\\\\n        }\\\\n    });\\\\n}\\\\n\\\\nfunction tree(data) {\\\\n    if (data.nodes.length > 0) {//有子节点\\\\n        for (let i = 0; i < data.nodes.length; i++) {\\\\n            childNodes.push(data.nodes[i].comment);\\\\n            tree(data.nodes[i]);//递归，直到没有子节点\\\\n        }\\\\n    }\\\\n}\\\\n```\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\",\\\"articleContentType\\\":\\\"1\\\",\\\"articleStatus\\\":\\\"1\\\"}\"}', '221.232.63.96', '2019-08-04 20:37:20');
INSERT INTO `t_blog_log` VALUES (33, 'admin', '修改文章是否推荐状态', '51', 'com.blog.admin.controller.ArticleController.changeRec()', '  id: {\"id\":5}', '221.232.63.96', '2019-08-04 20:37:32');
INSERT INTO `t_blog_log` VALUES (34, 'admin', '修改文章是否主页显示状态', '81', 'com.blog.admin.controller.ArticleController.changeMain()', '  id: {\"id\":5}', '221.232.63.96', '2019-08-04 20:37:33');
INSERT INTO `t_blog_log` VALUES (35, 'admin', '添加标签', '44', 'com.blog.admin.controller.TagController.addTag()', '  data: {\"data\":\"{\\\"tag_name\\\":\\\"读书笔记\\\"}\"}', '111.60.62.205', '2019-09-27 11:33:23');
INSERT INTO `t_blog_log` VALUES (36, 'admin', '审核评论', '23', 'com.blog.admin.controller.CommentController.auditComment()', '  data: {\"data\":\"{\\\"id\\\":\\\"efc62bba2c1d40eb829c17d32c863878\\\",\\\"radio\\\":\\\"no\\\",\\\"commentRemark\\\":\\\"\\\",\\\"isEmail\\\":false,\\\"show\\\":true}\"}', '121.32.150.235', '2019-10-18 19:54:11');
INSERT INTO `t_blog_log` VALUES (37, 'admin', '审核评论', '14', 'com.blog.admin.controller.CommentController.auditComment()', '  data: {\"data\":\"{\\\"id\\\":\\\"efc62bba2c1d40eb829c17d32c863878\\\",\\\"radio\\\":\\\"yes\\\",\\\"commentRemark\\\":\\\"\\\",\\\"isEmail\\\":false,\\\"show\\\":false}\"}', '103.27.26.88', '2019-10-20 23:54:06');

-- ----------------------------
-- Table structure for t_blog_siteinfo
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_siteinfo`;
CREATE TABLE `t_blog_siteinfo`  (
  `ID` int(11) NOT NULL,
  `site_name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '站点名称',
  `site_dec` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '站点描述',
  `site_blog_address` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '博客地址',
  `site_address` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '后台地址',
  `site_img` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网站图标',
  `site_logo` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网站logo',
  `site_copyright` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '版权信息',
  `site_number` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备案号',
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_siteinfo
-- ----------------------------
INSERT INTO `t_blog_siteinfo` VALUES (1, '刘帅的个人博客', '欢迎来到刘帅的个人博客', 'http://lsblog.vip', 'http://lsblog.vip/admin', 'http://lsblog.vip/log_30.png', 'http://lsblog.vip/logo.png', '2019 © liushuai', '鄂ICP备19001900号');

-- ----------------------------
-- Table structure for t_blog_sitestatistics
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_sitestatistics`;
CREATE TABLE `t_blog_sitestatistics`  (
  `ID` int(11) NOT NULL,
  `ss_article_counts` int(5) NULL DEFAULT NULL COMMENT '文章总数',
  `ss_tag_counts` int(3) NULL DEFAULT NULL COMMENT '标签总数',
  `ss_classify_counts` int(2) NULL DEFAULT NULL COMMENT '分类总数',
  `ss_comment_counts` int(5) NULL DEFAULT NULL COMMENT '留言总数',
  `ss_run_days` int(4) NULL DEFAULT NULL COMMENT '运行天数',
  `ss_last_updatetime` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '最后更新时间',
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_sitestatistics
-- ----------------------------
INSERT INTO `t_blog_sitestatistics` VALUES (1, 22, 12, 5, 12, 32, '2019-07-18 17:26:19');

-- ----------------------------
-- Table structure for t_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tag`;
CREATE TABLE `t_blog_tag`  (
  `ID` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `tag_creation_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `tag_last_update_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `is_delete` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_tag
-- ----------------------------
INSERT INTO `t_blog_tag` VALUES (1, 'SpringMVC', '2019-08-01 15:35:50', '2019-08-01 15:35:50', '0');
INSERT INTO `t_blog_tag` VALUES (2, 'JavaSE', '2019-08-01 15:42:06', '2019-08-01 15:42:06', '0');
INSERT INTO `t_blog_tag` VALUES (3, 'JavaEE', '2019-08-01 15:42:13', '2019-08-01 15:42:13', '0');
INSERT INTO `t_blog_tag` VALUES (4, '基础', '2019-08-01 15:44:53', '2019-08-01 15:44:53', '0');
INSERT INTO `t_blog_tag` VALUES (5, 'Spring', '2019-08-01 15:55:54', '2019-08-01 15:55:54', '0');
INSERT INTO `t_blog_tag` VALUES (6, 'MyBatis', '2019-08-01 16:01:46', '2019-08-01 16:01:46', '0');
INSERT INTO `t_blog_tag` VALUES (7, '插件', '2019-08-01 16:01:56', '2019-08-01 16:01:56', '0');
INSERT INTO `t_blog_tag` VALUES (8, '框架', '2019-08-04 03:00:20', '2019-08-04 03:00:20', '0');
INSERT INTO `t_blog_tag` VALUES (9, '系统设计', '2019-08-04 20:32:04', '2019-08-04 20:32:04', '0');
INSERT INTO `t_blog_tag` VALUES (10, '读书笔记', '2019-09-27 11:33:23', '2019-09-27 11:33:23', '0');

-- ----------------------------
-- Table structure for t_blog_webmasterinfo
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_webmasterinfo`;
CREATE TABLE `t_blog_webmasterinfo`  (
  `ID` int(11) NOT NULL,
  `wm_name` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '站长名称',
  `wm_email` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '站长邮箱',
  `wm_weixin` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '微信二维码地址',
  `wm_alipay` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '支付宝地址',
  `wm_qq` varchar(12) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'qq号码',
  `wm_github` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'GitHub地址',
  `wm_account` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '登录账号',
  `wm_password` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '登录密码',
  `wm_head_img` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像地址',
  `wm_dec` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '自我简介',
  PRIMARY KEY (`ID`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_webmasterinfo
-- ----------------------------
INSERT INTO `t_blog_webmasterinfo` VALUES (1, 'OIA', '1877281935@163.com', 'http://lsblog.vip/weixin.png', 'http://lsblog.vip/zhifubao.png', '919584210', 'https://github.com/MrLsss', 'admin', '123123', 'http://lsblog.vip/userHead/head.png', '19届毕业生,菜鸟,想要学好Java,想有大佬指点');

SET FOREIGN_KEY_CHECKS = 1;
